<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href="//cdn.staticfile.net/Primer/21.0.7/primer.css" rel="stylesheet" />
    <link rel="icon" href="https://avatars.githubusercontent.com/u/38165902?v=4"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="[toc]

- c语言描述
- 环境任意
- 算法和核心思想
- 代码实现

**分类**

* 交换类
  * 冒泡排序
  * 快速排序
* 分配类
  * 计数排序
  * 基数排序
* 选择类
  * 选择排序
  * 堆排序
* 归并类
  * 归并排序
* 插入类
  * 插入排序
  * 希尔排序



## 冒泡排序

- 一个基于交换的排序。">
<meta property="og:title" content="十大经典排序算法(各种优化)">
<meta property="og:description" content="[toc]

- c语言描述
- 环境任意
- 算法和核心思想
- 代码实现

**分类**

* 交换类
  * 冒泡排序
  * 快速排序
* 分配类
  * 计数排序
  * 基数排序
* 选择类
  * 选择排序
  * 堆排序
* 归并类
  * 归并排序
* 插入类
  * 插入排序
  * 希尔排序



## 冒泡排序

- 一个基于交换的排序。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://nickyoung0514.github.io/yblog.github.io/post/shi-da-jing-dian-pai-xu-suan-fa-%28-ge-zhong-you-hua-%29.html">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/38165902?v=4">
<title>十大经典排序算法(各种优化)</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />

</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">十大经典排序算法(各种优化)</h1>
<div class="title-right">
    <a href="https://nickyoung0514.github.io/yblog.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/nickyoung0514/yblog.github.io/issues/3" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><p>[toc]</p>
<ul>
<li>c语言描述</li>
<li>环境任意</li>
<li>算法和核心思想</li>
<li>代码实现</li>
</ul>
<p><strong>分类</strong></p>
<ul>
<li>交换类
<ul>
<li>冒泡排序</li>
<li>快速排序</li>
</ul>
</li>
<li>分配类
<ul>
<li>计数排序</li>
<li>基数排序</li>
</ul>
</li>
<li>选择类
<ul>
<li>选择排序</li>
<li>堆排序</li>
</ul>
</li>
<li>归并类
<ul>
<li>归并排序</li>
</ul>
</li>
<li>插入类
<ul>
<li>插入排序</li>
<li>希尔排序</li>
</ul>
</li>
</ul>
<h2>冒泡排序</h2>
<ul>
<li>一个基于交换的排序。每一轮将序列的最大值放到序列的尾部。</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">void</span> <span class="pl-en">bubSort</span>(<span class="pl-k">int</span> arr[],<span class="pl-k">int</span> length){<span class="pl-c"><span class="pl-c">//</span>1.冒泡排序</span>
	<span class="pl-k">while</span>(length--){
		<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">0</span>;i&lt;length;i++){
			<span class="pl-k">if</span>(arr[i+<span class="pl-c1">1</span>]&lt;arr[i]) <span class="pl-c1">swap</span>(arr[i],arr[i+<span class="pl-c1">1</span>]);
		}
	}
	
}

<span class="pl-k">void</span> <span class="pl-en">bubSort1</span>(<span class="pl-k">int</span> arr[],<span class="pl-k">int</span> length){<span class="pl-c"><span class="pl-c">//</span>1.冒泡排序优化</span>
	<span class="pl-k">int</span> flag=<span class="pl-c1">1</span>;
	<span class="pl-k">while</span>(length-- &amp;&amp; flag){
		flag=<span class="pl-c1">0</span>;
		<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">0</span>;i&lt;length;i++){
			<span class="pl-k">if</span>(arr[i+<span class="pl-c1">1</span>]&lt;arr[i]) {flag=<span class="pl-c1">1</span>;<span class="pl-c1">swap</span>(arr[i],arr[i+<span class="pl-c1">1</span>]);}
		}
	}	
}
</pre></div>
<p>优化有的冒泡排序比优化前的冒泡效率高的原因：<strong>当序列在找到所有最大值之前就已经将序列排好序时，直接结束。</strong></p>
<h2>选择排序</h2>
<ul>
<li>其实选择排序的基本思想还是冒泡排序。<strong>每一轮找到序列中的最小值后和第一个元素进行交换，以此类推。</strong></li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">void</span> <span class="pl-en">selectSort</span>(<span class="pl-k">int</span> arr[],<span class="pl-k">int</span> length){<span class="pl-c"><span class="pl-c">//</span>2.选择排序，演示：6 7 1 5 3 2</span>
	<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">0</span>;i&lt;length;i++){
		<span class="pl-k">int</span> k=i;<span class="pl-c"><span class="pl-c">//</span>k记录i的位置</span>
		<span class="pl-k">for</span>(<span class="pl-k">int</span> j=i+<span class="pl-c1">1</span>;j&lt;length;j++){<span class="pl-c"><span class="pl-c">//</span>j从假定最小值i后一位开始</span>
			<span class="pl-k">if</span>(arr[j]&lt;arr[k]) k=j;<span class="pl-c"><span class="pl-c">//</span>更新k的位置</span>
		}
		<span class="pl-c1">swap</span>(arr[i],arr[k]);<span class="pl-c"><span class="pl-c">//</span>此轮选定的假定最小值i，和实际最小值k 交换</span>
	}
}</pre></div>
<h2>插入排序</h2>
<ul>
<li>优点是：当原始序列已经基本有序时，再将一个新的数据插入进来，比较方便，也比较高效。</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">void</span> <span class="pl-en">insertSort</span>(<span class="pl-k">int</span> arr[],<span class="pl-k">int</span> length){<span class="pl-c"><span class="pl-c">//</span>3.插入排序，演示：1 2 3 7 6 5 4</span>
	<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">1</span>;i&lt;length;i++){<span class="pl-c"><span class="pl-c">//</span>arr[0]有序 从1开始比较</span>
		<span class="pl-k">for</span>(<span class="pl-k">int</span> j=i;j&gt;=<span class="pl-c1">1</span>&amp;&amp;arr[j]&lt;arr[j-<span class="pl-c1">1</span>];j--) <span class="pl-c1">swap</span>(arr[j],arr[j-<span class="pl-c1">1</span>]);
	}
}</pre></div>
<h2>希尔排序</h2>
<p>优化版的插入排序。优化的地方就是步长增大了，原来插入排序的步长是1，而希尔排序的步长可以很大，然后逐渐减小直到1形成插入排序。处理大量数据，希尔排序更占优。</p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">void</span> <span class="pl-en">shellSort</span>(<span class="pl-k">int</span> arr[],<span class="pl-k">int</span> length){
	<span class="pl-k">int</span> h=<span class="pl-c1">4</span>;<span class="pl-c"><span class="pl-c">//</span>初始步长为4</span>
	<span class="pl-k">while</span>(h&gt;=<span class="pl-c1">1</span>){
		<span class="pl-k">for</span>(<span class="pl-k">int</span> i=h;i&lt;length;i++){<span class="pl-c"><span class="pl-c">//</span>arr[0]有序 从1开始比较</span>
			<span class="pl-k">for</span>(<span class="pl-k">int</span> j=i;j&gt;=h&amp;&amp;arr[j]&lt;arr[j-h];j-=h) <span class="pl-c1">swap</span>(arr[j],arr[j-h]);
		}
		h/=<span class="pl-c1">2</span>;<span class="pl-c"><span class="pl-c">//</span>每次抽样排序后步长除2，直到步长为1</span>
	}
}</pre></div>
<p>经典的希尔序列：1,4,13,...,3 * n+1</p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">void</span> <span class="pl-en">shellSort1</span>(<span class="pl-k">int</span> arr[],<span class="pl-k">int</span> length){<span class="pl-c"><span class="pl-c">//</span>4.希尔排序优化</span>
	<span class="pl-k">int</span> h=<span class="pl-c1">1</span>;
	<span class="pl-k">int</span> t=length/<span class="pl-c1">3</span>;
	<span class="pl-k">while</span>(h&lt;t) h=<span class="pl-c1">3</span>*h+<span class="pl-c1">1</span>;
	<span class="pl-k">while</span>(h&gt;=<span class="pl-c1">1</span>){
		<span class="pl-k">for</span>(<span class="pl-k">int</span> i=h;i&lt;length;i++){<span class="pl-c"><span class="pl-c">//</span>arr[0]有序 从1开始比较</span>
			<span class="pl-k">for</span>(<span class="pl-k">int</span> j=i;j&gt;=h&amp;&amp;arr[j]&lt;arr[j-h];j-=h) <span class="pl-c1">swap</span>(arr[j],arr[j-h]);
		}
		h/=<span class="pl-c1">3</span>;<span class="pl-c"><span class="pl-c">//</span>每次抽样排序后步长除3，直到步长为1</span>
	}
}</pre></div>
<h2>快速排序</h2>
<p>冒泡排序的优化版本。核心思想：使用轴，每一轮左右递归后，把轴放到中间，使得轴的左边都比轴小，轴的右边比轴大。当所有的递归都结束了，就自然排好序了。适合数据杂乱无章的序列。</p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">void</span> <span class="pl-en">quickSort</span>(<span class="pl-k">int</span> arr[],<span class="pl-k">int</span> left,<span class="pl-k">int</span> right){<span class="pl-c"><span class="pl-c">//</span>5.快速排序</span>
	<span class="pl-k">if</span>(left&gt;=right) <span class="pl-k">return</span>;<span class="pl-c"><span class="pl-c">//</span>只有一个元素时</span>
	<span class="pl-k">int</span> i=left,j=right;
	<span class="pl-k">int</span> pivot=arr[i];<span class="pl-c"><span class="pl-c">//</span>轴为左边第一个值</span>
	<span class="pl-k">while</span>(i&lt;j){<span class="pl-c"><span class="pl-c">//</span>找轴</span>
		<span class="pl-k">while</span>(i&lt;j &amp;&amp; arr[j]&gt;=pivot) j--;<span class="pl-c"><span class="pl-c">//</span>从右开始，找比轴小的，否则指针j左移</span>
		arr[i]=arr[j];
		<span class="pl-k">while</span>(i&lt;j &amp;&amp; arr[i]&lt;=pivot) i++;<span class="pl-c"><span class="pl-c">//</span>从左开始，找比轴大的，否则指针i右移</span>
		arr[j]=arr[i];
	}
	arr[i]=pivot;<span class="pl-c"><span class="pl-c">//</span>找到轴，放入i位置</span>
	<span class="pl-c1">quickSort</span>(arr,left,i-<span class="pl-c1">1</span>);<span class="pl-c"><span class="pl-c">//</span>第i个位置为轴的位置</span>
	<span class="pl-c1">quickSort</span>(arr,i+<span class="pl-c1">1</span>,right);
}</pre></div>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">void</span> <span class="pl-en">quickSort2</span>(<span class="pl-k">int</span> arr[],<span class="pl-k">int</span> left,<span class="pl-k">int</span> right){
	<span class="pl-k">if</span>(left&gt;=right) <span class="pl-k">return</span>;
	<span class="pl-k">int</span> pivot=arr[left];
	<span class="pl-k">int</span> i=left+<span class="pl-c1">1</span>;
	<span class="pl-k">int</span> j=left+<span class="pl-c1">1</span>;
	<span class="pl-k">while</span>(j&lt;=right){<span class="pl-c"><span class="pl-c">//</span>指针j还没到右边界时</span>
		<span class="pl-k">if</span>(arr[j]&lt;pivot){<span class="pl-c1">swap</span>(arr[i],arr[j]); i++;}
		j++;
	}
	<span class="pl-c1">swap</span>(arr[left],arr[i-<span class="pl-c1">1</span>]);
	<span class="pl-c1">quickSort2</span>(arr,left,i-<span class="pl-c1">2</span>);
	<span class="pl-c1">quickSort2</span>(arr,i,right);
}</pre></div>
<h2>归并排序</h2>
<p>基于分而治之的思想。拿两个有序序列合并成一个新的有序序列。</p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">void</span> <span class="pl-en">mergeSort</span>(<span class="pl-k">int</span> a[],<span class="pl-k">int</span> alen,<span class="pl-k">int</span> b[],<span class="pl-k">int</span> blen,<span class="pl-k">int</span> *temp){<span class="pl-c"><span class="pl-c">//</span>6.归并排序</span>
	<span class="pl-k">int</span> i=<span class="pl-c1">0</span>;<span class="pl-c"><span class="pl-c">//</span>左指针</span>
	<span class="pl-k">int</span> j=<span class="pl-c1">0</span>;<span class="pl-c"><span class="pl-c">//</span>右指针</span>
	<span class="pl-k">int</span> k=<span class="pl-c1">0</span>;<span class="pl-c"><span class="pl-c">//</span>新数组的下标</span>
	<span class="pl-k">while</span>(i&lt;alen &amp;&amp; j&lt;blen){
		<span class="pl-k">if</span>(a[i]&lt;b[j]){temp[k]=a[i]; k++; i++;}<span class="pl-c"><span class="pl-c">//</span>a[i]小，加入数组，指针后移</span>
		<span class="pl-k">else</span> { temp[k]=b[j]; k++; j++;}
	}
	<span class="pl-k">while</span>(i&lt;alen){temp[k]=a[i]; k++; i++;}<span class="pl-c"><span class="pl-c">//</span>合并完，后续a[]还有没合并，则合并</span>
	<span class="pl-k">while</span>(j&lt;blen){temp[k]=b[j]; k++; j++;}<span class="pl-c"><span class="pl-c">//</span>合并完，后续b[]还有没合并，则合并</span>
}</pre></div>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">void</span> <span class="pl-en">mergeSort2</span>(<span class="pl-k">int</span> a[],<span class="pl-k">int</span> alen,<span class="pl-k">int</span> b[],<span class="pl-k">int</span> blen,<span class="pl-k">int</span> *temp){<span class="pl-c"><span class="pl-c">//</span>6.归并排序优化:两个有序列表合并</span>
	<span class="pl-k">int</span> i=<span class="pl-c1">0</span>;<span class="pl-c"><span class="pl-c">//</span>左指针</span>
	<span class="pl-k">int</span> j=<span class="pl-c1">0</span>;<span class="pl-c"><span class="pl-c">//</span>右指针</span>
	<span class="pl-k">int</span> k=<span class="pl-c1">0</span>;<span class="pl-c"><span class="pl-c">//</span>新数组的下标</span>
	<span class="pl-k">while</span>(i&lt;alen &amp;&amp; j&lt;blen) temp[k++]=a[i] &lt; b[j] ? a[i++] : b[j++];
	<span class="pl-k">while</span>(i&lt;alen) temp[k++] = a[i++]; 
	<span class="pl-k">while</span>(j&lt;blen) temp[k++] = b[j++]; 
}</pre></div>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">void</span> <span class="pl-en">merge</span>(<span class="pl-k">int</span> arr[],<span class="pl-k">int</span> low,<span class="pl-k">int</span> mid,<span class="pl-k">int</span> height,<span class="pl-k">int</span> *temp){<span class="pl-c"><span class="pl-c">//</span>6.归并排序无序版</span>
	<span class="pl-k">int</span> i=low;
	<span class="pl-k">int</span> j=mid+<span class="pl-c1">1</span>;
	<span class="pl-k">int</span> k=low;
	<span class="pl-k">while</span>(i&lt;=mid &amp;&amp; j&lt;=height)	temp[k++]=arr[i]&lt;arr[j]? arr[i++]:arr[j++];
	<span class="pl-k">while</span>(i&lt;=mid)	 temp[k++]=arr[i++];
	<span class="pl-k">while</span>(j&lt;=height) temp[k++]=arr[j++];
	<span class="pl-k">for</span>(i = low; i&lt;=height; i++) arr[i]=temp[i];<span class="pl-c"><span class="pl-c">//</span>将temp[]复制到a[]</span>
}

<span class="pl-k">void</span> <span class="pl-en">merge_sort</span>(<span class="pl-k">int</span> arr[],<span class="pl-k">int</span> low,<span class="pl-k">int</span> height,<span class="pl-k">int</span> *temp){
	<span class="pl-k">if</span>(low&gt;=height) <span class="pl-k">return</span>;
	<span class="pl-k">int</span> mid=low+(height-low)/<span class="pl-c1">2</span>; <span class="pl-c"><span class="pl-c">//</span>(low+height)/2</span>
	<span class="pl-c1">merge_sort</span>(arr,low,mid,temp);
	<span class="pl-c1">merge_sort</span>(arr,mid+<span class="pl-c1">1</span>,height,temp);
	<span class="pl-c1">merge</span>(arr,low,mid,height,temp);
}

<span class="pl-k">void</span> <span class="pl-en">mergeSort3</span>(<span class="pl-k">int</span> arr[],<span class="pl-k">int</span> length){
	<span class="pl-k">int</span> *temp =(<span class="pl-k">int</span> *)<span class="pl-c1">malloc</span>(<span class="pl-k">sizeof</span>(<span class="pl-k">int</span>)*length);
<span class="pl-c"><span class="pl-c">//</span>	assert(temp);//断点处理</span>
	<span class="pl-c1">merge_sort</span>(arr,<span class="pl-c1">0</span>,length-<span class="pl-c1">1</span>,temp);
	<span class="pl-c1">free</span>(temp);
}</pre></div>
<h2>堆排序</h2>
<p>去构建推结构的时候，有外堆和内堆。</p>
<ul>
<li>外堆：需要一段和原来长度大小相同的内存空间，这段内存空间用来存储堆结构。</li>
<li>内堆：不需要重新申请内存，直接在原来的数组上来进行排序</li>
</ul>
<p>堆结构：本质上是一个完全二叉树，每一个结点的存储都是连续的。</p>
<p>知道当前下标是current</p>
<ul>
<li>
<p>从0开始计数</p>
<ul>
<li>左子树--&gt; 2*current+1</li>
<li>右子树--&gt; 2*current+2</li>
</ul>
</li>
<li>
<p>从1开始计数</p>
<ul>
<li>左子树--&gt; 2*current</li>
<li>右子树--&gt; 2*current+1</li>
</ul>
</li>
<li>
<p>大顶堆</p>
<ul>
<li>父亲的权值比左右子树的权值大</li>
</ul>
</li>
<li>
<p>小顶堆</p>
<ul>
<li>父亲的权值比左右子树的权值小</li>
</ul>
</li>
<li>
<p>外堆实现</p>
</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">typedef</span> <span class="pl-k">struct</span> <span class="pl-en">Heap</span>{<span class="pl-c"><span class="pl-c">//</span>7.堆排序：堆结构</span>
	<span class="pl-k">int</span>* root;
	<span class="pl-k">int</span> length;
}Heap;

Heap* <span class="pl-en">CreateHeap</span>(<span class="pl-k">int</span> length){<span class="pl-c"><span class="pl-c">//</span>7.堆排序：申请堆结构（外堆）</span>
	Heap* heap=(Heap *)<span class="pl-c1">malloc</span>(<span class="pl-k">sizeof</span>(Heap));
	heap-&gt;<span class="pl-smi">length</span>=<span class="pl-c1">0</span>;
	heap-&gt;<span class="pl-smi">root</span> = (<span class="pl-k">int</span> *)<span class="pl-c1">malloc</span>(<span class="pl-k">sizeof</span>(<span class="pl-k">int</span>) * length);
	<span class="pl-k">return</span> heap;
}

<span class="pl-k">void</span> <span class="pl-en">pushHeap</span>(Heap* heap , <span class="pl-k">int</span> data){<span class="pl-c"><span class="pl-c">//</span>7.堆排序：入堆（外堆）</span>
	<span class="pl-k">int</span> current = heap-&gt;<span class="pl-smi">length</span>++;<span class="pl-c"><span class="pl-c">//</span>当前的下标++</span>
	<span class="pl-k">int</span> parent = current / <span class="pl-c1">2</span>;<span class="pl-c"><span class="pl-c">//</span>当前下标的父亲结点下标</span>
	heap-&gt;<span class="pl-smi">root</span>[current]=data;
	<span class="pl-k">while</span>(parent!=current){
		<span class="pl-k">if</span>(heap-&gt;<span class="pl-smi">root</span>[current] &lt; heap-&gt;<span class="pl-smi">root</span>[parent]){<span class="pl-c"><span class="pl-c">//</span>如果当前结点值比父亲值小，就交换</span>
			<span class="pl-c1">swap</span>(heap-&gt;<span class="pl-smi">root</span>[current] , heap-&gt;<span class="pl-smi">root</span>[parent]);
			current=parent;
			parent = current/<span class="pl-c1">2</span>;
		}<span class="pl-k">else</span> <span class="pl-k">break</span>;
	}
}

<span class="pl-k">int</span> <span class="pl-en">popHeap</span>(Heap* heap){<span class="pl-c"><span class="pl-c">//</span>7.堆排序：出堆（外堆）</span>
	<span class="pl-k">int</span> val=heap-&gt;<span class="pl-smi">root</span>[<span class="pl-c1">0</span>];<span class="pl-c"><span class="pl-c">//</span>堆顶位置</span>
	<span class="pl-k">int</span> current =<span class="pl-c1">0</span>;
	<span class="pl-k">int</span> rchild = <span class="pl-c1">2</span> * current + <span class="pl-c1">2</span>;
	<span class="pl-k">int</span> small;
	heap-&gt;<span class="pl-smi">root</span>[<span class="pl-c1">0</span>] = heap-&gt;<span class="pl-smi">root</span>[--heap-&gt;<span class="pl-smi">length</span>];<span class="pl-c"><span class="pl-c">//</span>根节点被覆盖</span>
	<span class="pl-k">while</span>(rchild &lt;= heap-&gt;<span class="pl-smi">length</span>){
		small=heap-&gt;<span class="pl-smi">root</span>[rchild-<span class="pl-c1">1</span>] &lt; heap-&gt;<span class="pl-smi">root</span>[rchild]? rchild-<span class="pl-c1">1</span> : rchild;<span class="pl-c"><span class="pl-c">//</span>左右子树谁小取谁</span>
		<span class="pl-k">if</span>(heap-&gt;<span class="pl-smi">root</span>[small]&lt;heap-&gt;<span class="pl-smi">root</span>[current]){
			<span class="pl-c1">swap</span>(heap-&gt;<span class="pl-smi">root</span>[small] , heap-&gt;<span class="pl-smi">root</span>[current]);
			current = small;
			rchild = <span class="pl-c1">2</span> * current+<span class="pl-c1">2</span>;
		}<span class="pl-k">else</span> <span class="pl-k">break</span>;
	}
	<span class="pl-k">return</span> val;
}
<span class="pl-c"><span class="pl-c">/*</span>伪代码</span>
<span class="pl-c">arr[MXSIZE];</span>
<span class="pl-c">for(arr){</span>
<span class="pl-c">pushHeap(heap,arr[i])</span>
<span class="pl-c">}</span>
<span class="pl-c">for(arr){</span>
<span class="pl-c">arr[i]=popHeap(heap)</span>
<span class="pl-c">}</span>
<span class="pl-c"><span class="pl-c">*/</span></span>

<span class="pl-k">void</span> <span class="pl-en">heapSort</span>(<span class="pl-k">int</span> arr[],<span class="pl-k">int</span> length){<span class="pl-c"><span class="pl-c">//</span>7.堆排序（外堆）</span>
	Heap* heap=<span class="pl-c1">CreateHeap</span>(MAXSIZE);
	<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">0</span>;i&lt;MAXSIZE;i++)	<span class="pl-c1">pushHeap</span>(heap,arr[i]);
	<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">0</span>;i&lt;MAXSIZE;i++)	arr[i]=<span class="pl-c1">popHeap</span>(heap);
	<span class="pl-c1">free</span>(heap-&gt;<span class="pl-smi">root</span>);
}
</pre></div>
<ul>
<li>内堆实现</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-c"><span class="pl-c">//</span>不需要申请空间</span>

<span class="pl-k">void</span> <span class="pl-en">Heapify</span>(<span class="pl-k">int</span> arr[],<span class="pl-k">int</span> length,<span class="pl-k">int</span> current){<span class="pl-c"><span class="pl-c">//</span>7.堆排序（内堆）</span>
	<span class="pl-k">int</span> rchild=<span class="pl-c1">2</span>*current+<span class="pl-c1">2</span>;
	<span class="pl-k">int</span> large;
	<span class="pl-k">while</span>(rchild&lt;=length){
		<span class="pl-c"><span class="pl-c">//</span></span>
		large=rchild==length?rchild-<span class="pl-c1">1</span> : (arr[rchild-<span class="pl-c1">1</span>]&gt;arr[rchild]? rchild-<span class="pl-c1">1</span>:rchild);<span class="pl-c"><span class="pl-c">//</span>左右子树谁大，拿谁</span>
		<span class="pl-k">if</span>(arr[large]&gt;arr[current]){
			<span class="pl-c1">swap</span>(arr[large],arr[current]);
			current = large;
			rchild = <span class="pl-c1">2</span> * current+<span class="pl-c1">2</span>;
		}<span class="pl-k">else</span> <span class="pl-k">break</span>;
	}
}



<span class="pl-k">void</span> <span class="pl-en">heapSort2</span>(<span class="pl-k">int</span> arr[],<span class="pl-k">int</span> length){<span class="pl-c"><span class="pl-c">//</span>7.堆排序（内堆）</span>
	<span class="pl-k">int</span> current = length/<span class="pl-c1">2</span>;<span class="pl-c"><span class="pl-c">//</span>取堆的尾点</span>
	<span class="pl-k">while</span>(current&gt;=<span class="pl-c1">0</span>){
		<span class="pl-c1">Heapify</span>(arr,length,current);
		current--;
	}
	<span class="pl-k">while</span>(length){
		<span class="pl-c1">swap</span>(arr[<span class="pl-c1">0</span>],arr[--length]);
		<span class="pl-c1">Heapify</span>(arr,length,<span class="pl-c1">0</span>);
		
	}
}</pre></div>
<h2>计数排序</h2>
<p>算法思想：统计原来数组的数据。大部分数据在一定范围内，而且重复很多，将数据转换成下标存储于一个临时空间中，然后变量临时空间把对应下标值放回原数组，当遍历临时空间完成后，原来的数组就是排好序了。</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">define</span> <span class="pl-en">N</span> <span class="pl-c1">100</span> 
<span class="pl-k">int</span> temp[N];
<span class="pl-k">void</span> <span class="pl-en">countSort</span>(<span class="pl-k">int</span> arr[],<span class="pl-k">int</span> length){<span class="pl-c"><span class="pl-c">//</span>9.计数排序</span>
	<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">0</span>;i&lt;length;i++)	temp[arr[i]]++;
	<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">0</span>,j=<span class="pl-c1">0</span>;i&lt;N;i++){
		<span class="pl-k">while</span>(temp[i]--)arr[j++]=i;
	}
}</pre></div>
<h2>基数排序</h2>
<p>154 423 365 251 78 92 640<br>
第一轮($10^0$位):640 251 92 423 154 365 78<br>
第二轮($10^1$位):423 640 251 154 365 78 92<br>
第三轮($10^2$位):78 92 154 251 365 423 640</p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> Temp[<span class="pl-c1">10</span>][N];
<span class="pl-k">void</span> <span class="pl-en">redixSort</span>(<span class="pl-k">int</span> arr[],<span class="pl-k">int</span> length){<span class="pl-c"><span class="pl-c">//</span>10.基数排序</span>
	<span class="pl-k">int</span> i,j,pos;
	<span class="pl-k">for</span>(<span class="pl-k">int</span> k=<span class="pl-c1">10</span>;k&lt;<span class="pl-c1">10000</span>;k*=<span class="pl-c1">10</span>){
		<span class="pl-k">for</span>(i=<span class="pl-c1">0</span>;i&lt;length;i++){
			j=<span class="pl-c1">0</span>;
			pos=(arr[i]%k) / (k/<span class="pl-c1">10</span>);
			<span class="pl-k">while</span>(Temp[pos][j])j++;
			Temp[pos][j]=arr[i];
		}
		pos=<span class="pl-c1">0</span>;
		<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">0</span>;i&lt;<span class="pl-c1">10</span>;i++){
			<span class="pl-k">for</span>(<span class="pl-k">int</span> j=<span class="pl-c1">0</span>;j&lt;length &amp;&amp; Temp[i][j]!=<span class="pl-c1">0</span>;j++){
				arr[pos++]=Temp[i][j];
				Temp[i][j]=<span class="pl-c1">0</span>;
			}
		}
	}
}
</pre></div>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>bits/stdc++.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>climits<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
#<span class="pl-k">define</span> <span class="pl-en">MAXSIZE</span> <span class="pl-c1">10</span>
#<span class="pl-k">define</span> <span class="pl-en">N</span> <span class="pl-c1">100</span>




<span class="pl-k">void</span> <span class="pl-en">initArr</span>(<span class="pl-k">int</span> arr[], <span class="pl-k">int</span> length) { <span class="pl-c"><span class="pl-c">//</span>数组初始化函数</span>
	<span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; length; i++) {
		arr[i] = <span class="pl-c1">rand</span>() % (MAXSIZE * <span class="pl-c1">10</span>);
	}
}
<span class="pl-k">void</span> <span class="pl-en">showArr</span>(<span class="pl-k">int</span> arr[], <span class="pl-k">int</span> length) { <span class="pl-c"><span class="pl-c">//</span>数组打印函数</span>
	<span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; length; i++) {
		<span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>%d <span class="pl-pds">"</span></span>, arr[i]);
	}
	<span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\n</span>----------------------------------------------------<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>);
}

<span class="pl-k">void</span> <span class="pl-en">bubSort</span>(<span class="pl-k">int</span> arr[], <span class="pl-k">int</span> length) { <span class="pl-c"><span class="pl-c">//</span>1.冒泡排序</span>
	<span class="pl-k">while</span> (length--) {
		<span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; length; i++) {
			<span class="pl-k">if</span> (arr[i + <span class="pl-c1">1</span>] &lt; arr[i]) <span class="pl-c1">swap</span>(arr[i], arr[i + <span class="pl-c1">1</span>]);
		}
	}

}

<span class="pl-k">void</span> <span class="pl-en">bubSort1</span>(<span class="pl-k">int</span> arr[], <span class="pl-k">int</span> length) { <span class="pl-c"><span class="pl-c">//</span>1.冒泡排序优化</span>
	<span class="pl-k">int</span> flag = <span class="pl-c1">1</span>;
	<span class="pl-k">while</span> (length-- &amp;&amp; flag) {
		flag = <span class="pl-c1">0</span>;
		<span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; length; i++) {
			<span class="pl-k">if</span> (arr[i + <span class="pl-c1">1</span>] &lt; arr[i]) {
				flag = <span class="pl-c1">1</span>;
				<span class="pl-c1">swap</span>(arr[i], arr[i + <span class="pl-c1">1</span>]);
			}
		}
	}
}

<span class="pl-k">void</span> <span class="pl-en">selectSort</span>(<span class="pl-k">int</span> arr[], <span class="pl-k">int</span> length) { <span class="pl-c"><span class="pl-c">//</span>2.选择排序，演示：6 7 1 5 3 2</span>
	<span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; length; i++) {
		<span class="pl-k">int</span> k = i; <span class="pl-c"><span class="pl-c">//</span>k记录i的位置</span>
		<span class="pl-k">for</span> (<span class="pl-k">int</span> j = i + <span class="pl-c1">1</span>; j &lt; length; j++) { <span class="pl-c"><span class="pl-c">//</span>j从假定最小值i后一位开始</span>
			<span class="pl-k">if</span> (arr[j] &lt; arr[k]) k = j; <span class="pl-c"><span class="pl-c">//</span>更新k的位置</span>
		}
		<span class="pl-c1">swap</span>(arr[i], arr[k]); <span class="pl-c"><span class="pl-c">//</span>此轮选定的假定最小值i，和实际最小值k 交换</span>
	}
}

<span class="pl-k">void</span> <span class="pl-en">insertSort</span>(<span class="pl-k">int</span> arr[], <span class="pl-k">int</span> length) { <span class="pl-c"><span class="pl-c">//</span>3.插入排序，演示：1 2 3 7 6 5 4</span>
	<span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">1</span>; i &lt; length; i++) { <span class="pl-c"><span class="pl-c">//</span>arr[0]有序 从1开始比较</span>
		<span class="pl-k">for</span> (<span class="pl-k">int</span> j = i; j &gt;= <span class="pl-c1">1</span> &amp;&amp; arr[j] &lt; arr[j - <span class="pl-c1">1</span>]; j--) <span class="pl-c1">swap</span>(arr[j], arr[j - <span class="pl-c1">1</span>]);
	}
}

<span class="pl-k">void</span> <span class="pl-en">shellSort</span>(<span class="pl-k">int</span> arr[], <span class="pl-k">int</span> length) { <span class="pl-c"><span class="pl-c">//</span>4.希尔排序</span>
	<span class="pl-k">int</span> h = <span class="pl-c1">4</span>; <span class="pl-c"><span class="pl-c">//</span>初始步长为4</span>
	<span class="pl-k">while</span> (h &gt;= <span class="pl-c1">1</span>) {
		<span class="pl-k">for</span> (<span class="pl-k">int</span> i = h; i &lt; length; i++) { <span class="pl-c"><span class="pl-c">//</span>arr[0]有序 从1开始比较</span>
			<span class="pl-k">for</span> (<span class="pl-k">int</span> j = i; j &gt;= h &amp;&amp; arr[j] &lt; arr[j - h]; j -= h) <span class="pl-c1">swap</span>(arr[j], arr[j - h]);
		}
		h /= <span class="pl-c1">2</span>; <span class="pl-c"><span class="pl-c">//</span>每次抽样排序后步长除2，直到步长为1</span>
	}
}

<span class="pl-k">void</span> <span class="pl-en">shellSort1</span>(<span class="pl-k">int</span> arr[], <span class="pl-k">int</span> length) { <span class="pl-c"><span class="pl-c">//</span>4.希尔排序优化</span>
	<span class="pl-k">int</span> h = <span class="pl-c1">1</span>;
	<span class="pl-k">int</span> t = length / <span class="pl-c1">3</span>;
	<span class="pl-k">while</span> (h &lt; t) h = <span class="pl-c1">3</span> * h + <span class="pl-c1">1</span>;
	<span class="pl-k">while</span> (h &gt;= <span class="pl-c1">1</span>) {
		<span class="pl-k">for</span> (<span class="pl-k">int</span> i = h; i &lt; length; i++) { <span class="pl-c"><span class="pl-c">//</span>arr[0]有序 从1开始比较</span>
			<span class="pl-k">for</span> (<span class="pl-k">int</span> j = i; j &gt;= h &amp;&amp; arr[j] &lt; arr[j - h]; j -= h) <span class="pl-c1">swap</span>(arr[j], arr[j - h]);
		}
		h /= <span class="pl-c1">3</span>; <span class="pl-c"><span class="pl-c">//</span>每次抽样排序后步长除3，直到步长为1</span>
	}
}

<span class="pl-k">void</span> <span class="pl-en">quickSort</span>(<span class="pl-k">int</span> arr[], <span class="pl-k">int</span> left, <span class="pl-k">int</span> right) { <span class="pl-c"><span class="pl-c">//</span>5.快速排序</span>
	<span class="pl-k">if</span> (left &gt;= right) <span class="pl-k">return</span>; <span class="pl-c"><span class="pl-c">//</span>只有一个元素时</span>
	<span class="pl-k">int</span> i = left, j = right;
	<span class="pl-k">int</span> pivot = arr[i]; <span class="pl-c"><span class="pl-c">//</span>轴为左边第一个值</span>
	<span class="pl-k">while</span> (i &lt; j) { <span class="pl-c"><span class="pl-c">//</span>找轴</span>
		<span class="pl-k">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) j--; <span class="pl-c"><span class="pl-c">//</span>从右开始，找比轴小的，否则指针j左移</span>
		arr[i] = arr[j];
		<span class="pl-k">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++; <span class="pl-c"><span class="pl-c">//</span>从左开始，找比轴大的，否则指针i右移</span>
		arr[j] = arr[i];
	}
	arr[i] = pivot; <span class="pl-c"><span class="pl-c">//</span>找到轴，放入i位置</span>
	<span class="pl-c1">quickSort</span>(arr, left, i - <span class="pl-c1">1</span>); <span class="pl-c"><span class="pl-c">//</span>第i个位置为轴的位置</span>
	<span class="pl-c1">quickSort</span>(arr, i + <span class="pl-c1">1</span>, right);
}

<span class="pl-k">void</span> <span class="pl-en">quickSort2</span>(<span class="pl-k">int</span> arr[], <span class="pl-k">int</span> left, <span class="pl-k">int</span> right) { <span class="pl-c"><span class="pl-c">//</span>5.快速排序优化</span>
	<span class="pl-k">if</span> (left &gt;= right) <span class="pl-k">return</span>;
	<span class="pl-k">int</span> pivot = arr[left];
	<span class="pl-k">int</span> i = left + <span class="pl-c1">1</span>;
	<span class="pl-k">int</span> j = left + <span class="pl-c1">1</span>;
	<span class="pl-k">while</span> (j &lt;= right) { <span class="pl-c"><span class="pl-c">//</span>指针j还没到右边界时</span>
		<span class="pl-k">if</span> (arr[j] &lt; pivot) {
			<span class="pl-c1">swap</span>(arr[i], arr[j]);
			i++;
		}
		j++;
	}
	<span class="pl-c1">swap</span>(arr[left], arr[i - <span class="pl-c1">1</span>]);
	<span class="pl-c1">quickSort2</span>(arr, left, i - <span class="pl-c1">2</span>);
	<span class="pl-c1">quickSort2</span>(arr, i, right);
}

<span class="pl-k">void</span> <span class="pl-en">mergeSort1</span>(<span class="pl-k">int</span> a[], <span class="pl-k">int</span> alen, <span class="pl-k">int</span> b[], <span class="pl-k">int</span> blen, <span class="pl-k">int</span> *temp) { <span class="pl-c"><span class="pl-c">//</span>6.归并排序:两个有序列表合并</span>
	<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; <span class="pl-c"><span class="pl-c">//</span>左指针</span>
	<span class="pl-k">int</span> j = <span class="pl-c1">0</span>; <span class="pl-c"><span class="pl-c">//</span>右指针</span>
	<span class="pl-k">int</span> k = <span class="pl-c1">0</span>; <span class="pl-c"><span class="pl-c">//</span>新数组的下标</span>
	<span class="pl-k">while</span> (i &lt; alen &amp;&amp; j &lt; blen) {
		<span class="pl-k">if</span> (a[i] &lt; b[j]) {
			temp[k] = a[i];    <span class="pl-c"><span class="pl-c">//</span>a[i]小，加入数组，指针后移</span>
			k++;
			i++;
		} <span class="pl-k">else</span> {
			temp[k] = b[j];
			k++;
			j++;
		}
	}
	<span class="pl-k">while</span> (i &lt; alen) {
		temp[k] = a[i];    <span class="pl-c"><span class="pl-c">//</span>合并完，后续a[]还有没合并，则合并</span>
		k++;
		i++;
	}
	<span class="pl-k">while</span> (j &lt; blen) {
		temp[k] = b[j];    <span class="pl-c"><span class="pl-c">//</span>合并完，后续b[]还有没合并，则合并</span>
		k++;
		j++;
	}
}

<span class="pl-k">void</span> <span class="pl-en">mergeSort2</span>(<span class="pl-k">int</span> a[], <span class="pl-k">int</span> alen, <span class="pl-k">int</span> b[], <span class="pl-k">int</span> blen, <span class="pl-k">int</span> *temp) { <span class="pl-c"><span class="pl-c">//</span>6.归并排序优化:两个有序列表合并</span>
	<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; <span class="pl-c"><span class="pl-c">//</span>左指针</span>
	<span class="pl-k">int</span> j = <span class="pl-c1">0</span>; <span class="pl-c"><span class="pl-c">//</span>右指针</span>
	<span class="pl-k">int</span> k = <span class="pl-c1">0</span>; <span class="pl-c"><span class="pl-c">//</span>新数组的下标</span>
	<span class="pl-k">while</span> (i &lt; alen &amp;&amp; j &lt; blen) temp[k++] = a[i] &lt; b[j] ? a[i++] : b[j++];
	<span class="pl-k">while</span> (i &lt; alen) temp[k++] = a[i++];
	<span class="pl-k">while</span> (j &lt; blen) temp[k++] = b[j++];
}

<span class="pl-k">void</span> <span class="pl-en">merge</span>(<span class="pl-k">int</span> arr[], <span class="pl-k">int</span> low, <span class="pl-k">int</span> mid, <span class="pl-k">int</span> height, <span class="pl-k">int</span> *temp) { <span class="pl-c"><span class="pl-c">//</span>6.归并排序无序版</span>
	<span class="pl-k">int</span> i = low;
	<span class="pl-k">int</span> j = mid + <span class="pl-c1">1</span>;
	<span class="pl-k">int</span> k = low;
	<span class="pl-k">while</span> (i &lt;= mid &amp;&amp; j &lt;= height)	temp[k++] = arr[i] &lt; arr[j] ? arr[i++] : arr[j++];
	<span class="pl-k">while</span> (i &lt;= mid)	 temp[k++] = arr[i++];
	<span class="pl-k">while</span> (j &lt;= height) temp[k++] = arr[j++];
	<span class="pl-k">for</span> (i = low; i &lt;= height; i++) arr[i] = temp[i]; <span class="pl-c"><span class="pl-c">//</span>将temp[]复制到a[]</span>
}

<span class="pl-k">void</span> <span class="pl-en">merge_sort</span>(<span class="pl-k">int</span> arr[], <span class="pl-k">int</span> low, <span class="pl-k">int</span> height, <span class="pl-k">int</span> *temp) {
	<span class="pl-k">if</span> (low &gt;= height) <span class="pl-k">return</span>;
	<span class="pl-k">int</span> mid = low + (height - low) / <span class="pl-c1">2</span>; <span class="pl-c"><span class="pl-c">//</span>(low+height)/2</span>
	<span class="pl-c1">merge_sort</span>(arr, low, mid, temp);
	<span class="pl-c1">merge_sort</span>(arr, mid + <span class="pl-c1">1</span>, height, temp);
	<span class="pl-c1">merge</span>(arr, low, mid, height, temp);
}

<span class="pl-k">void</span> <span class="pl-en">mergeSort3</span>(<span class="pl-k">int</span> arr[], <span class="pl-k">int</span> length) {
	<span class="pl-k">int</span> *temp = (<span class="pl-k">int</span> *)<span class="pl-c1">malloc</span>(<span class="pl-k">sizeof</span>(<span class="pl-k">int</span>) * length);
<span class="pl-c"><span class="pl-c">//</span>	assert(temp);//断点处理</span>
	<span class="pl-c1">merge_sort</span>(arr, <span class="pl-c1">0</span>, length - <span class="pl-c1">1</span>, temp);
	<span class="pl-c1">free</span>(temp);
}



<span class="pl-k">typedef</span> <span class="pl-k">struct</span> <span class="pl-en">Heap</span> { <span class="pl-c"><span class="pl-c">//</span>7.堆排序：堆结构</span>
	<span class="pl-k">int</span>* root;
	<span class="pl-k">int</span> length;
} Heap;

Heap* <span class="pl-en">CreateHeap</span>(<span class="pl-k">int</span> length) { <span class="pl-c"><span class="pl-c">//</span>7.堆排序：申请堆结构（外堆）</span>
	Heap* heap = (Heap *)<span class="pl-c1">malloc</span>(<span class="pl-k">sizeof</span>(Heap));
	heap-&gt;<span class="pl-smi">length</span> = <span class="pl-c1">0</span>;
	heap-&gt;<span class="pl-smi">root</span> = (<span class="pl-k">int</span> *)<span class="pl-c1">malloc</span>(<span class="pl-k">sizeof</span>(<span class="pl-k">int</span>) * length);
	<span class="pl-k">return</span> heap;
}

<span class="pl-k">void</span> <span class="pl-en">pushHeap</span>(Heap* heap, <span class="pl-k">int</span> data) {<span class="pl-c"><span class="pl-c">//</span>7.堆排序：入堆（外堆）</span>
	<span class="pl-k">int</span> current = heap-&gt;<span class="pl-smi">length</span>++;<span class="pl-c"><span class="pl-c">//</span>当前的下标++</span>
	<span class="pl-k">int</span> parent = current / <span class="pl-c1">2</span>;<span class="pl-c"><span class="pl-c">//</span>当前下标的父亲结点下标</span>
	heap-&gt;<span class="pl-smi">root</span>[current] = data;
	<span class="pl-k">while</span> (parent != current) {
		<span class="pl-k">if</span> (heap-&gt;<span class="pl-smi">root</span>[current] &lt; heap-&gt;<span class="pl-smi">root</span>[parent]) { <span class="pl-c"><span class="pl-c">//</span>如果当前结点值比父亲值小，就交换</span>
			<span class="pl-c1">swap</span>(heap-&gt;<span class="pl-smi">root</span>[current], heap-&gt;<span class="pl-smi">root</span>[parent]);
			current = parent;
			parent = current / <span class="pl-c1">2</span>;
		} <span class="pl-k">else</span> <span class="pl-k">break</span>;
	}
}

<span class="pl-k">int</span> <span class="pl-en">popHeap</span>(Heap* heap) { <span class="pl-c"><span class="pl-c">//</span>7.堆排序：出堆（外堆）</span>
	<span class="pl-k">int</span> val = heap-&gt;<span class="pl-smi">root</span>[<span class="pl-c1">0</span>]; <span class="pl-c"><span class="pl-c">//</span>堆顶位置</span>
	<span class="pl-k">int</span> current = <span class="pl-c1">0</span>;
	<span class="pl-k">int</span> rchild = <span class="pl-c1">2</span> * current + <span class="pl-c1">2</span>;
	<span class="pl-k">int</span> small;
	heap-&gt;<span class="pl-smi">root</span>[<span class="pl-c1">0</span>] = heap-&gt;<span class="pl-smi">root</span>[--heap-&gt;<span class="pl-smi">length</span>];<span class="pl-c"><span class="pl-c">//</span>根节点被覆盖</span>
	<span class="pl-k">while</span> (rchild &lt;= heap-&gt;<span class="pl-smi">length</span>) {
		small = heap-&gt;<span class="pl-smi">root</span>[rchild - <span class="pl-c1">1</span>] &lt; heap-&gt;<span class="pl-smi">root</span>[rchild] ? rchild - <span class="pl-c1">1</span> : rchild; <span class="pl-c"><span class="pl-c">//</span>左右子树谁小取谁</span>
		<span class="pl-k">if</span> (heap-&gt;<span class="pl-smi">root</span>[small] &lt; heap-&gt;<span class="pl-smi">root</span>[current]) {
			<span class="pl-c1">swap</span>(heap-&gt;<span class="pl-smi">root</span>[small], heap-&gt;<span class="pl-smi">root</span>[current]);
			current = small;
			rchild = <span class="pl-c1">2</span> * current + <span class="pl-c1">2</span>;
		} <span class="pl-k">else</span> <span class="pl-k">break</span>;
	}
	<span class="pl-k">return</span> val;
}
<span class="pl-c"><span class="pl-c">/*</span>伪代码</span>
<span class="pl-c">arr[MXSIZE];</span>
<span class="pl-c">for(arr){</span>
<span class="pl-c">pushHeap(heap,arr[i])</span>
<span class="pl-c">}</span>
<span class="pl-c">for(arr){</span>
<span class="pl-c">arr[i]=popHeap(heap)</span>
<span class="pl-c">}</span>
<span class="pl-c"><span class="pl-c">*/</span></span>

<span class="pl-k">void</span> <span class="pl-en">heapSort</span>(<span class="pl-k">int</span> arr[], <span class="pl-k">int</span> length) { <span class="pl-c"><span class="pl-c">//</span>7.堆排序（外堆）</span>
	Heap* heap = <span class="pl-c1">CreateHeap</span>(MAXSIZE);
	<span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; MAXSIZE; i++)	<span class="pl-c1">pushHeap</span>(heap, arr[i]);
	<span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; MAXSIZE; i++)	arr[i] = <span class="pl-c1">popHeap</span>(heap);
	<span class="pl-c1">free</span>(heap-&gt;<span class="pl-smi">root</span>);
}


<span class="pl-k">void</span> <span class="pl-en">Heapify</span>(<span class="pl-k">int</span> arr[], <span class="pl-k">int</span> length, <span class="pl-k">int</span> current) { <span class="pl-c"><span class="pl-c">//</span>7.堆排序（内堆）</span>
	<span class="pl-k">int</span> rchild = <span class="pl-c1">2</span> * current + <span class="pl-c1">2</span>;
	<span class="pl-k">int</span> large;
	<span class="pl-k">while</span> (rchild &lt;= length) {
		<span class="pl-c"><span class="pl-c">//</span></span>
		large = rchild == length ? rchild - <span class="pl-c1">1</span> : (arr[rchild - <span class="pl-c1">1</span>] &gt; arr[rchild] ? rchild - <span class="pl-c1">1</span> : rchild); <span class="pl-c"><span class="pl-c">//</span>左右子树谁大，拿谁</span>
		<span class="pl-k">if</span> (arr[large] &gt; arr[current]) {
			<span class="pl-c1">swap</span>(arr[large], arr[current]);
			current = large;
			rchild = <span class="pl-c1">2</span> * current + <span class="pl-c1">2</span>;
		} <span class="pl-k">else</span> <span class="pl-k">break</span>;
	}
}



<span class="pl-k">void</span> <span class="pl-en">heapSort2</span>(<span class="pl-k">int</span> arr[], <span class="pl-k">int</span> length) { <span class="pl-c"><span class="pl-c">//</span>7.堆排序（内堆）</span>
	<span class="pl-k">int</span> current = length / <span class="pl-c1">2</span>; <span class="pl-c"><span class="pl-c">//</span>取堆的尾点</span>
	<span class="pl-k">while</span> (current &gt;= <span class="pl-c1">0</span>) {
		<span class="pl-c1">Heapify</span>(arr, length, current);
		current--;
	}
	<span class="pl-k">while</span> (length) {
		<span class="pl-c1">swap</span>(arr[<span class="pl-c1">0</span>], arr[--length]);
		<span class="pl-c1">Heapify</span>(arr, length, <span class="pl-c1">0</span>);

	}
}


<span class="pl-k">int</span> temp[N];
<span class="pl-k">void</span> <span class="pl-en">countSort</span>(<span class="pl-k">int</span> arr[], <span class="pl-k">int</span> length) { <span class="pl-c"><span class="pl-c">//</span>9.计数排序</span>
	<span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; length; i++)	temp[arr[i]]++;
	<span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>, j = <span class="pl-c1">0</span>; i &lt; N; i++) {
		<span class="pl-k">while</span> (temp[i]--)arr[j++] = i;
	}
}

<span class="pl-k">int</span> Temp[<span class="pl-c1">10</span>][N];
<span class="pl-k">void</span> <span class="pl-en">redixSort</span>(<span class="pl-k">int</span> arr[], <span class="pl-k">int</span> length) { <span class="pl-c"><span class="pl-c">//</span>10.基数排序</span>
	<span class="pl-k">int</span> i, j, pos;
	<span class="pl-k">for</span> (<span class="pl-k">int</span> k = <span class="pl-c1">10</span>; k &lt; <span class="pl-c1">10000</span>; k * = <span class="pl-c1">10</span>) {
		<span class="pl-k">for</span> (i = <span class="pl-c1">0</span>; i &lt; length; i++) {
			j = <span class="pl-c1">0</span>;
			pos = (arr[i] % k) / (k / <span class="pl-c1">10</span>);
			<span class="pl-k">while</span> (Temp[pos][j])j++;
			Temp[pos][j] = arr[i];
		}
		pos = <span class="pl-c1">0</span>;
		<span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; <span class="pl-c1">10</span>; i++) {
			<span class="pl-k">for</span> (<span class="pl-k">int</span> j = <span class="pl-c1">0</span>; j &lt; length &amp;&amp; Temp[i][j] != <span class="pl-c1">0</span>; j++) {
				arr[pos++] = Temp[i][j];
				Temp[i][j] = <span class="pl-c1">0</span>;
			}
		}
	}
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {
	<span class="pl-c1">srand</span>((<span class="pl-k">unsigned</span> <span class="pl-k">int</span>)<span class="pl-c1">time</span>(<span class="pl-c1">NULL</span>));
	<span class="pl-k">int</span> arr[MAXSIZE];

	<span class="pl-c1">initArr</span>(arr, MAXSIZE);
	<span class="pl-c1">showArr</span>(arr, MAXSIZE);


	<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">	printf("冒泡排序：\n");</span>
<span class="pl-c">	bubSort1(arr,MAXSIZE);</span>
<span class="pl-c">	showArr(arr,MAXSIZE);</span>
<span class="pl-c"></span>
<span class="pl-c">	printf("选择排序：\n");</span>
<span class="pl-c">	selectSort(arr,MAXSIZE);</span>
<span class="pl-c">	showArr(arr,MAXSIZE);</span>
<span class="pl-c"></span>
<span class="pl-c">	printf("插入排序：\n");</span>
<span class="pl-c">	insertSort(arr,MAXSIZE);</span>
<span class="pl-c">	showArr(arr,MAXSIZE);</span>
<span class="pl-c"></span>
<span class="pl-c">	printf("希尔排序：\n");</span>
<span class="pl-c">	shellSort1(arr,MAXSIZE);</span>
<span class="pl-c">	showArr(arr,MAXSIZE);</span>
<span class="pl-c"></span>
<span class="pl-c"></span>
<span class="pl-c">	printf("希尔排序：\n");</span>
<span class="pl-c">	quickSort2(arr,0,MAXSIZE-1);</span>
<span class="pl-c">	showArr(arr,MAXSIZE);</span>
<span class="pl-c">	<span class="pl-c">*/</span></span>

	<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">	printf("归并排序：\n");</span>
<span class="pl-c">	int a[5]={1,3,5,7,9};</span>
<span class="pl-c">	int b[3]={2,8,10};</span>
<span class="pl-c">	int temp[8];</span>
<span class="pl-c">	mergeSort2(a,5,b,3,temp);</span>
<span class="pl-c">	showArr(temp,8);</span>
<span class="pl-c"></span>
<span class="pl-c">	mergeSort3(arr,MAXSIZE);</span>
<span class="pl-c">	showArr(arr,MAXSIZE);</span>
<span class="pl-c">	<span class="pl-c">*/</span></span>

	<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">	printf("堆排序(外堆)：\n");</span>
<span class="pl-c">	heapSort(arr,MAXSIZE);</span>
<span class="pl-c">	showArr(arr,MAXSIZE);</span>
<span class="pl-c"></span>
<span class="pl-c">	printf("堆排序（内堆）：\n");</span>
<span class="pl-c">	heapSort2(arr,MAXSIZE);</span>
<span class="pl-c">	showArr(arr,MAXSIZE);</span>
<span class="pl-c">	<span class="pl-c">*/</span></span>
	<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">	printf("计数排序：\n");</span>
<span class="pl-c">	countSort(arr,MAXSIZE);</span>
<span class="pl-c">	showArr(arr,MAXSIZE);</span>
<span class="pl-c">	<span class="pl-c">*/</span></span>
	<span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>计数排序：<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>);
	<span class="pl-c1">redixSort</span>(arr, MAXSIZE);
	<span class="pl-c1">showArr</span>(arr, MAXSIZE);
	<span class="pl-c1">system</span>(<span class="pl-s"><span class="pl-pds">"</span>pause<span class="pl-pds">"</span></span>);
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>
<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>
</div>
    <div id="footer">Copyright © <span id="year"></span><a href="https://nickyoung0514.github.io/yblog.github.io"> 任平生-博客 </a>
<p>
<span id="runday"></span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a>
</p>

<script>
if(""!=""){
    var now=new Date();
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("year").innerHTML=now.getFullYear();
    if(""!=""){document.getElementById("runday").innerHTML=" • "+"网站运行"+diffDay+"天"+" • ";}
    else{document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";}
}
</script>
</div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n\n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);

function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","nickyoung0514/yblog.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}
</script>
<script>MathJax = {tex: {inlineMath: [["$", "$"]]}};</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</html>
