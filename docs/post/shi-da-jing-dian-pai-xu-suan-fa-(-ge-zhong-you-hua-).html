<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://avatars.githubusercontent.com/u/38165902?v=4"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="[toc]

- c语言描述
- 环境任意
- 算法和核心思想
- 代码实现

**分类**

* 交换类
  * 冒泡排序
  * 快速排序
* 分配类
  * 计数排序
  * 基数排序
* 选择类
  * 选择排序
  * 堆排序
* 归并类
  * 归并排序
* 插入类
  * 插入排序
  * 希尔排序



## 冒泡排序

- 一个基于交换的排序。">
<meta property="og:title" content="十大经典排序算法(各种优化)">
<meta property="og:description" content="[toc]

- c语言描述
- 环境任意
- 算法和核心思想
- 代码实现

**分类**

* 交换类
  * 冒泡排序
  * 快速排序
* 分配类
  * 计数排序
  * 基数排序
* 选择类
  * 选择排序
  * 堆排序
* 归并类
  * 归并排序
* 插入类
  * 插入排序
  * 希尔排序



## 冒泡排序

- 一个基于交换的排序。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://nickyoung0514.github.io/yblog.github.io/post/shi-da-jing-dian-pai-xu-suan-fa-%28-ge-zhong-you-hua-%29.html">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/38165902?v=4">
<title>十大经典排序算法(各种优化)</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">十大经典排序算法(各种优化)</h1>
<div class="title-right">
    <a href="https://nickyoung0514.github.io/yblog.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/nickyoung0514/yblog.github.io/issues/3" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><p>[toc]</p>
<ul>
<li>c语言描述</li>
<li>环境任意</li>
<li>算法和核心思想</li>
<li>代码实现</li>
</ul>
<p><strong>分类</strong></p>
<ul>
<li>交换类
<ul>
<li>冒泡排序</li>
<li>快速排序</li>
</ul>
</li>
<li>分配类
<ul>
<li>计数排序</li>
<li>基数排序</li>
</ul>
</li>
<li>选择类
<ul>
<li>选择排序</li>
<li>堆排序</li>
</ul>
</li>
<li>归并类
<ul>
<li>归并排序</li>
</ul>
</li>
<li>插入类
<ul>
<li>插入排序</li>
<li>希尔排序</li>
</ul>
</li>
</ul>
<h2>冒泡排序</h2>
<ul>
<li>一个基于交换的排序。每一轮将序列的最大值放到序列的尾部。</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate">void bubSort(int arr[],int length){//1.冒泡排序
	while(length--){
		for(int i=0;i&lt;length;i++){
			if(arr[i+1]&lt;arr[i]) swap(arr[i],arr[i+1]);
		}
	}
	
}

void bubSort1(int arr[],int length){//1.冒泡排序优化
	int flag=1;
	while(length-- &amp;&amp; flag){
		flag=0;
		for(int i=0;i&lt;length;i++){
			if(arr[i+1]&lt;arr[i]) {flag=1;swap(arr[i],arr[i+1]);}
		}
	}	
}</pre></div>
<p>优化有的冒泡排序比优化前的冒泡效率高的原因：<strong>当序列在找到所有最大值之前就已经将序列排好序时，直接结束。</strong></p>
<h2>选择排序</h2>
<ul>
<li>其实选择排序的基本思想还是冒泡排序。<strong>每一轮找到序列中的最小值后和第一个元素进行交换，以此类推。</strong></li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate">void selectSort(int arr[],int length){//2.选择排序，演示：6 7 1 5 3 2
	for(int i=0;i&lt;length;i++){
		int k=i;//k记录i的位置
		for(int j=i+1;j&lt;length;j++){//j从假定最小值i后一位开始
			if(arr[j]&lt;arr[k]) k=j;//更新k的位置
		}
		swap(arr[i],arr[k]);//此轮选定的假定最小值i，和实际最小值k 交换
	}
}</pre></div>
<h2>插入排序</h2>
<ul>
<li>优点是：当原始序列已经基本有序时，再将一个新的数据插入进来，比较方便，也比较高效。</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate">void insertSort(int arr[],int length){//3.插入排序，演示：1 2 3 7 6 5 4
	for(int i=1;i&lt;length;i++){//arr[0]有序 从1开始比较
		for(int j=i;j&gt;=1&amp;&amp;arr[j]&lt;arr[j-1];j--) swap(arr[j],arr[j-1]);
	}
}</pre></div>
<h2>希尔排序</h2>
<p>优化版的插入排序。优化的地方就是步长增大了，原来插入排序的步长是1，而希尔排序的步长可以很大，然后逐渐减小直到1形成插入排序。处理大量数据，希尔排序更占优。</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">void shellSort(int arr[],int length){
	int h=4;//初始步长为4
	while(h&gt;=1){
		for(int i=h;i&lt;length;i++){//arr[0]有序 从1开始比较
			for(int j=i;j&gt;=h&amp;&amp;arr[j]&lt;arr[j-h];j-=h) swap(arr[j],arr[j-h]);
		}
		h/=2;//每次抽样排序后步长除2，直到步长为1
	}
}</pre></div>
<p>经典的希尔序列：1,4,13,...,3 * n+1</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">void shellSort1(int arr[],int length){//4.希尔排序优化
	int h=1;
	int t=length/3;
	while(h&lt;t) h=3*h+1;
	while(h&gt;=1){
		for(int i=h;i&lt;length;i++){//arr[0]有序 从1开始比较
			for(int j=i;j&gt;=h&amp;&amp;arr[j]&lt;arr[j-h];j-=h) swap(arr[j],arr[j-h]);
		}
		h/=3;//每次抽样排序后步长除3，直到步长为1
	}
}</pre></div>
<h2>快速排序</h2>
<p>冒泡排序的优化版本。核心思想：使用轴，每一轮左右递归后，把轴放到中间，使得轴的左边都比轴小，轴的右边比轴大。当所有的递归都结束了，就自然排好序了。适合数据杂乱无章的序列。</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">void quickSort(int arr[],int left,int right){//5.快速排序
	if(left&gt;=right) return;//只有一个元素时
	int i=left,j=right;
	int pivot=arr[i];//轴为左边第一个值
	while(i&lt;j){//找轴
		while(i&lt;j &amp;&amp; arr[j]&gt;=pivot) j--;//从右开始，找比轴小的，否则指针j左移
		arr[i]=arr[j];
		while(i&lt;j &amp;&amp; arr[i]&lt;=pivot) i++;//从左开始，找比轴大的，否则指针i右移
		arr[j]=arr[i];
	}
	arr[i]=pivot;//找到轴，放入i位置
	quickSort(arr,left,i-1);//第i个位置为轴的位置
	quickSort(arr,i+1,right);
}</pre></div>
<div class="highlight highlight-source-c++"><pre class="notranslate">void quickSort2(int arr[],int left,int right){
	if(left&gt;=right) return;
	int pivot=arr[left];
	int i=left+1;
	int j=left+1;
	while(j&lt;=right){//指针j还没到右边界时
		if(arr[j]&lt;pivot){swap(arr[i],arr[j]); i++;}
		j++;
	}
	swap(arr[left],arr[i-1]);
	quickSort2(arr,left,i-2);
	quickSort2(arr,i,right);
}</pre></div>
<h2>归并排序</h2>
<p>基于分而治之的思想。拿两个有序序列合并成一个新的有序序列。</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">void mergeSort(int a[],int alen,int b[],int blen,int *temp){//6.归并排序
	int i=0;//左指针
	int j=0;//右指针
	int k=0;//新数组的下标
	while(i&lt;alen &amp;&amp; j&lt;blen){
		if(a[i]&lt;b[j]){temp[k]=a[i]; k++; i++;}//a[i]小，加入数组，指针后移
		else { temp[k]=b[j]; k++; j++;}
	}
	while(i&lt;alen){temp[k]=a[i]; k++; i++;}//合并完，后续a[]还有没合并，则合并
	while(j&lt;blen){temp[k]=b[j]; k++; j++;}//合并完，后续b[]还有没合并，则合并
}</pre></div>
<div class="highlight highlight-source-c++"><pre class="notranslate">void mergeSort2(int a[],int alen,int b[],int blen,int *temp){//6.归并排序优化:两个有序列表合并
	int i=0;//左指针
	int j=0;//右指针
	int k=0;//新数组的下标
	while(i&lt;alen &amp;&amp; j&lt;blen) temp[k++]=a[i] &lt; b[j] ? a[i++] : b[j++];
	while(i&lt;alen) temp[k++] = a[i++]; 
	while(j&lt;blen) temp[k++] = b[j++]; 
}</pre></div>
<div class="highlight highlight-source-c++"><pre class="notranslate">void merge(int arr[],int low,int mid,int height,int *temp){//6.归并排序无序版
	int i=low;
	int j=mid+1;
	int k=low;
	while(i&lt;=mid &amp;&amp; j&lt;=height)	temp[k++]=arr[i]&lt;arr[j]? arr[i++]:arr[j++];
	while(i&lt;=mid)	 temp[k++]=arr[i++];
	while(j&lt;=height) temp[k++]=arr[j++];
	for(i = low; i&lt;=height; i++) arr[i]=temp[i];//将temp[]复制到a[]
}

void merge_sort(int arr[],int low,int height,int *temp){
	if(low&gt;=height) return;
	int mid=low+(height-low)/2; //(low+height)/2
	merge_sort(arr,low,mid,temp);
	merge_sort(arr,mid+1,height,temp);
	merge(arr,low,mid,height,temp);
}

void mergeSort3(int arr[],int length){
	int *temp =(int *)malloc(sizeof(int)*length);
//	assert(temp);//断点处理
	merge_sort(arr,0,length-1,temp);
	free(temp);
}</pre></div>
<h2>堆排序</h2>
<p>去构建推结构的时候，有外堆和内堆。</p>
<ul>
<li>外堆：需要一段和原来长度大小相同的内存空间，这段内存空间用来存储堆结构。</li>
<li>内堆：不需要重新申请内存，直接在原来的数组上来进行排序</li>
</ul>
<p>堆结构：本质上是一个完全二叉树，每一个结点的存储都是连续的。</p>
<p>知道当前下标是current</p>
<ul>
<li>
<p>从0开始计数</p>
<ul>
<li>左子树--&gt; 2*current+1</li>
<li>右子树--&gt; 2*current+2</li>
</ul>
</li>
<li>
<p>从1开始计数</p>
<ul>
<li>左子树--&gt; 2*current</li>
<li>右子树--&gt; 2*current+1</li>
</ul>
</li>
<li>
<p>大顶堆</p>
<ul>
<li>父亲的权值比左右子树的权值大</li>
</ul>
</li>
<li>
<p>小顶堆</p>
<ul>
<li>父亲的权值比左右子树的权值小</li>
</ul>
</li>
<li>
<p>外堆实现</p>
</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate">typedef struct Heap{//7.堆排序：堆结构
	int* root;
	int length;
}Heap;

Heap* CreateHeap(int length){//7.堆排序：申请堆结构（外堆）
	Heap* heap=(Heap *)malloc(sizeof(Heap));
	heap-&gt;length=0;
	heap-&gt;root = (int *)malloc(sizeof(int) * length);
	return heap;
}

void pushHeap(Heap* heap , int data){//7.堆排序：入堆（外堆）
	int current = heap-&gt;length++;//当前的下标++
	int parent = current / 2;//当前下标的父亲结点下标
	heap-&gt;root[current]=data;
	while(parent!=current){
		if(heap-&gt;root[current] &lt; heap-&gt;root[parent]){//如果当前结点值比父亲值小，就交换
			swap(heap-&gt;root[current] , heap-&gt;root[parent]);
			current=parent;
			parent = current/2;
		}else break;
	}
}

int popHeap(Heap* heap){//7.堆排序：出堆（外堆）
	int val=heap-&gt;root[0];//堆顶位置
	int current =0;
	int rchild = 2 * current + 2;
	int small;
	heap-&gt;root[0] = heap-&gt;root[--heap-&gt;length];//根节点被覆盖
	while(rchild &lt;= heap-&gt;length){
		small=heap-&gt;root[rchild-1] &lt; heap-&gt;root[rchild]? rchild-1 : rchild;//左右子树谁小取谁
		if(heap-&gt;root[small]&lt;heap-&gt;root[current]){
			swap(heap-&gt;root[small] , heap-&gt;root[current]);
			current = small;
			rchild = 2 * current+2;
		}else break;
	}
	return val;
}
/*伪代码
arr[MXSIZE];
for(arr){
pushHeap(heap,arr[i])
}
for(arr){
arr[i]=popHeap(heap)
}
*/

void heapSort(int arr[],int length){//7.堆排序（外堆）
	Heap* heap=CreateHeap(MAXSIZE);
	for(int i=0;i&lt;MAXSIZE;i++)	pushHeap(heap,arr[i]);
	for(int i=0;i&lt;MAXSIZE;i++)	arr[i]=popHeap(heap);
	free(heap-&gt;root);
}</pre></div>
<ul>
<li>内堆实现</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate">//不需要申请空间

void Heapify(int arr[],int length,int current){//7.堆排序（内堆）
	int rchild=2*current+2;
	int large;
	while(rchild&lt;=length){
		//
		large=rchild==length?rchild-1 : (arr[rchild-1]&gt;arr[rchild]? rchild-1:rchild);//左右子树谁大，拿谁
		if(arr[large]&gt;arr[current]){
			swap(arr[large],arr[current]);
			current = large;
			rchild = 2 * current+2;
		}else break;
	}
}



void heapSort2(int arr[],int length){//7.堆排序（内堆）
	int current = length/2;//取堆的尾点
	while(current&gt;=0){
		Heapify(arr,length,current);
		current--;
	}
	while(length){
		swap(arr[0],arr[--length]);
		Heapify(arr,length,0);
		
	}
}</pre></div>
<h2>计数排序</h2>
<p>算法思想：统计原来数组的数据。大部分数据在一定范围内，而且重复很多，将数据转换成下标存储于一个临时空间中，然后变量临时空间把对应下标值放回原数组，当遍历临时空间完成后，原来的数组就是排好序了。</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">#define N 100 
int temp[N];
void countSort(int arr[],int length){//9.计数排序
	for(int i=0;i&lt;length;i++)	temp[arr[i]]++;
	for(int i=0,j=0;i&lt;N;i++){
		while(temp[i]--)arr[j++]=i;
	}
}</pre></div>
<h2>基数排序</h2>
<p>154 423 365 251 78 92 640<br>
第一轮($10^0$位):640 251 92 423 154 365 78<br>
第二轮($10^1$位):423 640 251 154 365 78 92<br>
第三轮($10^2$位):78 92 154 251 365 423 640</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">int Temp[10][N];
void redixSort(int arr[],int length){//10.基数排序
	int i,j,pos;
	for(int k=10;k&lt;10000;k*=10){
		for(i=0;i&lt;length;i++){
			j=0;
			pos=(arr[i]%k) / (k/10);
			while(Temp[pos][j])j++;
			Temp[pos][j]=arr[i];
		}
		pos=0;
		for(int i=0;i&lt;10;i++){
			for(int j=0;j&lt;length &amp;&amp; Temp[i][j]!=0;j++){
				arr[pos++]=Temp[i][j];
				Temp[i][j]=0;
			}
		}
	}
}</pre></div>
<div class="highlight highlight-source-c++"><pre class="notranslate">#include&lt;bits/stdc++.h&gt;
#include&lt;assert.h&gt;
#include&lt;climits&gt;
<span class="pl-k">using</span> <span class="pl-k">namespace</span> std;
#define MAXSIZE 10
#define N 100




void initArr(int arr[], int length) { //数组初始化函数
	for (int i = 0; i &lt; length; i++) {
		arr[i] = rand() % (MAXSIZE * 10);
	}
}
void showArr(int arr[], int length) { //数组打印函数
	for (int i = 0; i &lt; length; i++) {
		printf("%d ", arr[i]);
	}
	printf("\n----------------------------------------------------\n");
}

void bubSort(int arr[], int length) { //1.冒泡排序
	while (length--) {
		for (int i = 0; i &lt; length; i++) {
			if (arr[i + 1] &lt; arr[i]) swap(arr[i], arr[i + 1]);
		}
	}

}

void bubSort1(int arr[], int length) { //1.冒泡排序优化
	int flag = 1;
	while (length-- &amp;&amp; flag) {
		flag = 0;
		for (int i = 0; i &lt; length; i++) {
			if (arr[i + 1] &lt; arr[i]) {
				flag = 1;
				swap(arr[i], arr[i + 1]);
			}
		}
	}
}

void selectSort(int arr[], int length) { //2.选择排序，演示：6 7 1 5 3 2
	for (int i = 0; i &lt; length; i++) {
		int k = i; //k记录i的位置
		for (int j = i + 1; j &lt; length; j++) { //j从假定最小值i后一位开始
			if (arr[j] &lt; arr[k]) k = j; //更新k的位置
		}
		swap(arr[i], arr[k]); //此轮选定的假定最小值i，和实际最小值k 交换
	}
}

void insertSort(int arr[], int length) { //3.插入排序，演示：1 2 3 7 6 5 4
	for (int i = 1; i &lt; length; i++) { //arr[0]有序 从1开始比较
		for (int j = i; j &gt;= 1 &amp;&amp; arr[j] &lt; arr[j - 1]; j--) swap(arr[j], arr[j - 1]);
	}
}

void shellSort(int arr[], int length) { //4.希尔排序
	int h = 4; //初始步长为4
	while (h &gt;= 1) {
		for (int i = h; i &lt; length; i++) { //arr[0]有序 从1开始比较
			for (int j = i; j &gt;= h &amp;&amp; arr[j] &lt; arr[j - h]; j -= h) swap(arr[j], arr[j - h]);
		}
		h /= 2; //每次抽样排序后步长除2，直到步长为1
	}
}

void shellSort1(int arr[], int length) { //4.希尔排序优化
	int h = 1;
	int t = length / 3;
	while (h &lt; t) h = 3 * h + 1;
	while (h &gt;= 1) {
		for (int i = h; i &lt; length; i++) { //arr[0]有序 从1开始比较
			for (int j = i; j &gt;= h &amp;&amp; arr[j] &lt; arr[j - h]; j -= h) swap(arr[j], arr[j - h]);
		}
		h /= 3; //每次抽样排序后步长除3，直到步长为1
	}
}

void quickSort(int arr[], int left, int right) { //5.快速排序
	if (left &gt;= right) return; //只有一个元素时
	int i = left, j = right;
	int pivot = arr[i]; //轴为左边第一个值
	while (i &lt; j) { //找轴
		while (i &lt; j &amp;&amp; arr[j] &gt;= pivot) j--; //从右开始，找比轴小的，否则指针j左移
		arr[i] = arr[j];
		while (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++; //从左开始，找比轴大的，否则指针i右移
		arr[j] = arr[i];
	}
	arr[i] = pivot; //找到轴，放入i位置
	quickSort(arr, left, i - 1); //第i个位置为轴的位置
	quickSort(arr, i + 1, right);
}

void quickSort2(int arr[], int left, int right) { //5.快速排序优化
	if (left &gt;= right) return;
	int pivot = arr[left];
	int i = left + 1;
	int j = left + 1;
	while (j &lt;= right) { //指针j还没到右边界时
		if (arr[j] &lt; pivot) {
			swap(arr[i], arr[j]);
			i++;
		}
		j++;
	}
	swap(arr[left], arr[i - 1]);
	quickSort2(arr, left, i - 2);
	quickSort2(arr, i, right);
}

void mergeSort1(int a[], int alen, int b[], int blen, int *temp) { //6.归并排序:两个有序列表合并
	int i = 0; //左指针
	int j = 0; //右指针
	int k = 0; //新数组的下标
	while (i &lt; alen &amp;&amp; j &lt; blen) {
		if (a[i] &lt; b[j]) {
			temp[k] = a[i];    //a[i]小，加入数组，指针后移
			k++;
			i++;
		} else {
			temp[k] = b[j];
			k++;
			j++;
		}
	}
	while (i &lt; alen) {
		temp[k] = a[i];    //合并完，后续a[]还有没合并，则合并
		k++;
		i++;
	}
	while (j &lt; blen) {
		temp[k] = b[j];    //合并完，后续b[]还有没合并，则合并
		k++;
		j++;
	}
}

void mergeSort2(int a[], int alen, int b[], int blen, int *temp) { //6.归并排序优化:两个有序列表合并
	int i = 0; //左指针
	int j = 0; //右指针
	int k = 0; //新数组的下标
	while (i &lt; alen &amp;&amp; j &lt; blen) temp[k++] = a[i] &lt; b[j] ? a[i++] : b[j++];
	while (i &lt; alen) temp[k++] = a[i++];
	while (j &lt; blen) temp[k++] = b[j++];
}

void merge(int arr[], int low, int mid, int height, int *temp) { //6.归并排序无序版
	int i = low;
	int j = mid + 1;
	int k = low;
	while (i &lt;= mid &amp;&amp; j &lt;= height)	temp[k++] = arr[i] &lt; arr[j] ? arr[i++] : arr[j++];
	while (i &lt;= mid)	 temp[k++] = arr[i++];
	while (j &lt;= height) temp[k++] = arr[j++];
	for (i = low; i &lt;= height; i++) arr[i] = temp[i]; //将temp[]复制到a[]
}

void merge_sort(int arr[], int low, int height, int *temp) {
	if (low &gt;= height) return;
	int mid = low + (height - low) / 2; //(low+height)/2
	merge_sort(arr, low, mid, temp);
	merge_sort(arr, mid + 1, height, temp);
	merge(arr, low, mid, height, temp);
}

void mergeSort3(int arr[], int length) {
	int *temp = (int *)malloc(sizeof(int) * length);
//	assert(temp);//断点处理
	merge_sort(arr, 0, length - 1, temp);
	free(temp);
}



typedef struct Heap { //7.堆排序：堆结构
	int* root;
	int length;
} Heap;

Heap* CreateHeap(int length) { //7.堆排序：申请堆结构（外堆）
	Heap* heap = (Heap *)malloc(sizeof(Heap));
	heap-&gt;length = 0;
	heap-&gt;root = (int *)malloc(sizeof(int) * length);
	return heap;
}

void pushHeap(Heap* heap, int data) {//7.堆排序：入堆（外堆）
	int current = heap-&gt;length++;//当前的下标++
	int parent = current / 2;//当前下标的父亲结点下标
	heap-&gt;root[current] = data;
	while (parent != current) {
		if (heap-&gt;root[current] &lt; heap-&gt;root[parent]) { //如果当前结点值比父亲值小，就交换
			swap(heap-&gt;root[current], heap-&gt;root[parent]);
			current = parent;
			parent = current / 2;
		} else break;
	}
}

int popHeap(Heap* heap) { //7.堆排序：出堆（外堆）
	int val = heap-&gt;root[0]; //堆顶位置
	int current = 0;
	int rchild = 2 * current + 2;
	int small;
	heap-&gt;root[0] = heap-&gt;root[--heap-&gt;length];//根节点被覆盖
	while (rchild &lt;= heap-&gt;length) {
		small = heap-&gt;root[rchild - 1] &lt; heap-&gt;root[rchild] ? rchild - 1 : rchild; //左右子树谁小取谁
		if (heap-&gt;root[small] &lt; heap-&gt;root[current]) {
			swap(heap-&gt;root[small], heap-&gt;root[current]);
			current = small;
			rchild = 2 * current + 2;
		} else break;
	}
	return val;
}
/*伪代码
arr[MXSIZE];
for(arr){
pushHeap(heap,arr[i])
}
for(arr){
arr[i]=popHeap(heap)
}
*/

void heapSort(int arr[], int length) { //7.堆排序（外堆）
	Heap* heap = CreateHeap(MAXSIZE);
	for (int i = 0; i &lt; MAXSIZE; i++)	pushHeap(heap, arr[i]);
	for (int i = 0; i &lt; MAXSIZE; i++)	arr[i] = popHeap(heap);
	free(heap-&gt;root);
}


void Heapify(int arr[], int length, int current) { //7.堆排序（内堆）
	int rchild = 2 * current + 2;
	int large;
	while (rchild &lt;= length) {
		//
		large = rchild == length ? rchild - 1 : (arr[rchild - 1] &gt; arr[rchild] ? rchild - 1 : rchild); //左右子树谁大，拿谁
		if (arr[large] &gt; arr[current]) {
			swap(arr[large], arr[current]);
			current = large;
			rchild = 2 * current + 2;
		} else break;
	}
}



void heapSort2(int arr[], int length) { //7.堆排序（内堆）
	int current = length / 2; //取堆的尾点
	while (current &gt;= 0) {
		Heapify(arr, length, current);
		current--;
	}
	while (length) {
		swap(arr[0], arr[--length]);
		Heapify(arr, length, 0);

	}
}


int temp[N];
void countSort(int arr[], int length) { //9.计数排序
	for (int i = 0; i &lt; length; i++)	temp[arr[i]]++;
	for (int i = 0, j = 0; i &lt; N; i++) {
		while (temp[i]--)arr[j++] = i;
	}
}

int Temp[10][N];
void redixSort(int arr[], int length) { //10.基数排序
	int i, j, pos;
	for (int k = 10; k &lt; 10000; k * = 10) {
		for (i = 0; i &lt; length; i++) {
			j = 0;
			pos = (arr[i] % k) / (k / 10);
			while (Temp[pos][j])j++;
			Temp[pos][j] = arr[i];
		}
		pos = 0;
		for (int i = 0; i &lt; 10; i++) {
			for (int j = 0; j &lt; length &amp;&amp; Temp[i][j] != 0; j++) {
				arr[pos++] = Temp[i][j];
				Temp[i][j] = 0;
			}
		}
	}
}

int main() {
	srand((unsigned int)time(NULL));
	int arr[MAXSIZE];

	initArr(arr, MAXSIZE);
	showArr(arr, MAXSIZE);


	/*
	printf("冒泡排序：\n");
	bubSort1(arr,MAXSIZE);
	showArr(arr,MAXSIZE);

	printf("选择排序：\n");
	selectSort(arr,MAXSIZE);
	showArr(arr,MAXSIZE);

	printf("插入排序：\n");
	insertSort(arr,MAXSIZE);
	showArr(arr,MAXSIZE);

	printf("希尔排序：\n");
	shellSort1(arr,MAXSIZE);
	showArr(arr,MAXSIZE);


	printf("希尔排序：\n");
	quickSort2(arr,0,MAXSIZE-1);
	showArr(arr,MAXSIZE);
	*/

	/*
	printf("归并排序：\n");
	int a[5]={1,3,5,7,9};
	int b[3]={2,8,10};
	int temp[8];
	mergeSort2(a,5,b,3,temp);
	showArr(temp,8);

	mergeSort3(arr,MAXSIZE);
	showArr(arr,MAXSIZE);
	*/

	/*
	printf("堆排序(外堆)：\n");
	heapSort(arr,MAXSIZE);
	showArr(arr,MAXSIZE);

	printf("堆排序（内堆）：\n");
	heapSort2(arr,MAXSIZE);
	showArr(arr,MAXSIZE);
	*/
	/*
	printf("计数排序：\n");
	countSort(arr,MAXSIZE);
	showArr(arr,MAXSIZE);
	*/
	printf("计数排序：\n");
	redixSort(arr, MAXSIZE);
	showArr(arr, MAXSIZE);
	system("pause");
	return 0;
}</pre></div></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://nickyoung0514.github.io/yblog.github.io">任平生-博客</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","nickyoung0514/yblog.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script>MathJax = {tex: {inlineMath: [["$", "$"]]}};</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</html>
