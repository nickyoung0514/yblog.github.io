<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://avatars.githubusercontent.com/u/38165902?v=4"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content=" 

#### 文章目录

*   *   [一. 类和对象](#__2)
    *   *   [1.1 封装](#11__16)
        *   *   [1.1.1 封装的意义](#111___17)
            *   [1.1.2 struct和class区别](#112_structclass_163)
            *   [1.1.3 成员属性设置为私有](#113__193)
        *   [1.2 对象的初始化和清理](#12__260)
        *   *   [1.2.1 构造函数和析构函数](#121__264)
            *   [1.2.2 构造函数的分类及调用](#122__321)
            *   [1.2.3 拷贝构造函数调用时机](#123__404)
            *   [1.2.4 构造函数调用规则](#124__481)
            *   [1.2.5 深拷贝与浅拷贝](#125__556)
            *   [1.2.6 初始化列表](#126__624)
            *   [1.2.7 类对象作为类成员](#127__666)
            *   [1.2.8 静态成员](#128__744)
        *   [1.3 C++对象模型和this指针](#13_Cthis_869)
        *   *   [1.3.1 成员变量和成员函数分开存储](#131__870)
            *   [1.3.2 this指针概念](#132_this_902)
            *   [1.3.3 空指针访问成员函数](#133__959)
            *   [1.3.4 const修饰成员函数](#134_const_1003)
        *   [1.4 友元](#14__1070)
        *   *   [1.4.1 全局函数做友元](#141__1089)
            *   [1.4.2 类做友元](#142__1137)
            *   [1.4.3 成员函数做友元](#143__1200)
        *   [1.5 运算符重载](#15__1268)
        *   *   [1.5.1 加号运算符重载](#151__1271)
            *   [1.5.2 左移运算符重载](#152__1341)
            *   [1.5.3 递增运算符重载](#153__1390)
            *   [1.5.4 赋值运算符重载](#154__1456)
            *   [1.5.5 关系运算符重载](#155__1549)
            *   [1.5.6 函数调用运算符重载](#156__1628)
        *   [1.6 继承](#16___1681)
        *   *   [1.6.1 继承的基本语法](#161__1686)
            *   [1.6.2 继承方式](#162__1904)
            *   [1.6.3 继承中的对象模型](#163__2004)
            *   [1.6.4 继承中构造和析构顺序](#164__2046)
            *   [1.6.5 继承同名成员处理方式](#165__2097)
            *   [1.6.6 继承同名静态成员处理方式](#166__2170)
            *   [1.6.7 多继承语法](#167__2250)
            *   [1.6.8 菱形继承](#168__2317)
        *   [1.7 多态](#17___2372)
        *   *   [1.7.1 多态的基本概念](#171__2373)
            *   [1.7.2 多态案例一-计算器类](#172__2467)
            *   [1.7.3 纯虚函数和抽象类](#173__2602)
            *   [1.7.4 多态案例二-制作饮品](#174__2657)
            *   [1.7.5 虚析构和纯虚析构](#175__2754)
            *   [1.7.6 多态案例三-电脑组装](#176__2866)

### 一. 类和对象

C++[面向对象](https://so.csdn.net/so/search?q=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1&spm=1001.2101.3001.7020)的三大特性为：封装、继承、多态

C++认为万事万物都皆为对象，对象上有其属性和行为

**例如：**

 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…

 车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…

 具有相同性质的对象，我们可以抽象称为类，人属于人类，车属于车类

#### 1.1 封装

##### 1.1.1 封装的意义

封装是C++面向对象三大特性之一，封装的意义：

*   将属性和行为作为一个整体，表现生活中的事物
*   将属性和行为加以权限控制

**封装意义一：**

 在设计类的时候，属性和行为写在一起，表现事物

**语法：** `class 类名{ 访问权限： 属性 / 行为 };`

**示例1：** 设计一个圆类，求[圆的周长](https://so.csdn.net/so/search?q=%E5%9C%86%E7%9A%84%E5%91%A8%E9%95%BF&spm=1001.2101.3001.7020)

**示例代码：**

```cpp
//圆周率
const double PI = 3.14;

//1、封装的意义
//将属性和行为作为一个整体，用来表现生活中的事物

//封装一个圆类，求圆的周长
//class代表设计一个类，后面跟着的是类名
class Circle
{
public:  //访问权限  公共的权限

	//属性
	int m_r;//半径

	//行为
	//获取到圆的周长
	double calculateZC()
	{
		//2 * pi  * r
		//获取圆的周长
		return  2 * PI * m_r;
	}
};

int main() {

	//通过圆类，创建圆的对象
	// c1就是一个具体的圆
	Circle c1;
	c1.m_r = 10; //给圆对象的半径 进行赋值操作

	//2 * pi * 10 = = 62.8
	cout << '圆的周长为： ' << c1.calculateZC() << endl;
	
	return 0;
}
```

**示例2：** 设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号

**示例2代码：**

```cpp
//学生类
class Student {
public:
	void setName(string name) {
		m_name = name;
	}
	void setID(int id) {
		m_id = id;
	}

	void showStudent() {
		cout << 'name:' << m_name << ' ID:' << m_id << endl;
	}
public:
	string m_name;
	int m_id;
};

int main() {

	Student stu;
	stu.setName('德玛西亚');
	stu.setID(250);
	stu.showStudent();

	return 0;
}

```

**封装意义二：**

类在设计时，可以把属性和行为放在不同的权限下，加以控制，[访问权限](https://so.csdn.net/so/search?q=%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90&spm=1001.2101.3001.7020)有三种：

1.  public 公共权限
2.  protected 保护权限
3.  private 私有权限

**示例：**

```cpp
//三种权限
//公共权限  public     类内可以访问  类外可以访问
//保护权限  protected  类内可以访问  类外不可以访问
//私有权限  private    类内可以访问  类外不可以访问

class Person
{
	//姓名  公共权限
public:
	string m_Name;

	//汽车  保护权限
protected:
	string m_Car;

	//银行卡密码  私有权限
private:
	int m_Password;

public:
	void func()
	{
		m_Name = '张三';
		m_Car = '拖拉机';
		m_Password = 123456;
	}
};

int main() {

	Person p;
	p.m_Name = '李四';
	//p.m_Car = '奔驰';  //保护权限类外访问不到
	//p.m_Password = 123; //私有权限类外访问不到

	return 0;
}
```

##### 1.1.2 struct和class区别

在C++中 struct和class唯一的**区别**就在于 **默认的访问权限不同**，区别：

*   struct 默认权限为公共
*   class 默认权限为私有

```cpp
class C1
{
	int  m_A; //默认是私有权限
};

struct C2
{
	int m_A;  //默认是公共权限
};

int main() {

	C1 c1;
	c1.m_A = 10; //错误，访问权限是私有

	C2 c2;
	c2.m_A = 10; //正确，访问权限是公共

	system('pause');

	return 0;
}
```

##### 1.1.3 成员属性设置为私有

**优点1：** 将所有成员属性设置为私有，可以自己控制读写权限

**优点2：** 对于写权限，我们可以检测数据的有效性

**示例：**

```cpp
class Person {
public:

	//姓名设置可读可写
	void setName(string name) {
		m_Name = name;
	}
	string getName()
	{
		return m_Name;
	}

	//获取年龄 
	int getAge() {
		return m_Age;
	}
	//设置年龄
	void setAge(int age) {
		if (age < 0 || age > 150) {
			cout << '你个老妖精!' << endl;
			return;
		}
		m_Age = age;
	}

	//情人设置为只写
	void setLover(string lover) {
		m_Lover = lover;
	}

private:
	string m_Name; //可读可写  姓名
	
	int m_Age; //只读  年龄

	string m_Lover; //只写  情人
};

int main() {

	Person p;
	//姓名设置
	p.setName('张三');
	cout << '姓名： ' << p.getName() << endl;

	//年龄设置
	p.setAge(50);
	cout << '年龄： ' << p.getAge() << endl;

	//情人设置
	p.setLover('苍井');
	//cout << '情人： ' << p.m_Lover << endl;  //只写属性，不可以读取

	return 0;
}
```

#### 1.2 对象的初始化和清理

*   生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全
*   C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。">
<meta property="og:title" content="【C++核心】一文理解C++面向对象（详细）">
<meta property="og:description" content=" 

#### 文章目录

*   *   [一. 类和对象](#__2)
    *   *   [1.1 封装](#11__16)
        *   *   [1.1.1 封装的意义](#111___17)
            *   [1.1.2 struct和class区别](#112_structclass_163)
            *   [1.1.3 成员属性设置为私有](#113__193)
        *   [1.2 对象的初始化和清理](#12__260)
        *   *   [1.2.1 构造函数和析构函数](#121__264)
            *   [1.2.2 构造函数的分类及调用](#122__321)
            *   [1.2.3 拷贝构造函数调用时机](#123__404)
            *   [1.2.4 构造函数调用规则](#124__481)
            *   [1.2.5 深拷贝与浅拷贝](#125__556)
            *   [1.2.6 初始化列表](#126__624)
            *   [1.2.7 类对象作为类成员](#127__666)
            *   [1.2.8 静态成员](#128__744)
        *   [1.3 C++对象模型和this指针](#13_Cthis_869)
        *   *   [1.3.1 成员变量和成员函数分开存储](#131__870)
            *   [1.3.2 this指针概念](#132_this_902)
            *   [1.3.3 空指针访问成员函数](#133__959)
            *   [1.3.4 const修饰成员函数](#134_const_1003)
        *   [1.4 友元](#14__1070)
        *   *   [1.4.1 全局函数做友元](#141__1089)
            *   [1.4.2 类做友元](#142__1137)
            *   [1.4.3 成员函数做友元](#143__1200)
        *   [1.5 运算符重载](#15__1268)
        *   *   [1.5.1 加号运算符重载](#151__1271)
            *   [1.5.2 左移运算符重载](#152__1341)
            *   [1.5.3 递增运算符重载](#153__1390)
            *   [1.5.4 赋值运算符重载](#154__1456)
            *   [1.5.5 关系运算符重载](#155__1549)
            *   [1.5.6 函数调用运算符重载](#156__1628)
        *   [1.6 继承](#16___1681)
        *   *   [1.6.1 继承的基本语法](#161__1686)
            *   [1.6.2 继承方式](#162__1904)
            *   [1.6.3 继承中的对象模型](#163__2004)
            *   [1.6.4 继承中构造和析构顺序](#164__2046)
            *   [1.6.5 继承同名成员处理方式](#165__2097)
            *   [1.6.6 继承同名静态成员处理方式](#166__2170)
            *   [1.6.7 多继承语法](#167__2250)
            *   [1.6.8 菱形继承](#168__2317)
        *   [1.7 多态](#17___2372)
        *   *   [1.7.1 多态的基本概念](#171__2373)
            *   [1.7.2 多态案例一-计算器类](#172__2467)
            *   [1.7.3 纯虚函数和抽象类](#173__2602)
            *   [1.7.4 多态案例二-制作饮品](#174__2657)
            *   [1.7.5 虚析构和纯虚析构](#175__2754)
            *   [1.7.6 多态案例三-电脑组装](#176__2866)

### 一. 类和对象

C++[面向对象](https://so.csdn.net/so/search?q=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1&spm=1001.2101.3001.7020)的三大特性为：封装、继承、多态

C++认为万事万物都皆为对象，对象上有其属性和行为

**例如：**

 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…

 车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…

 具有相同性质的对象，我们可以抽象称为类，人属于人类，车属于车类

#### 1.1 封装

##### 1.1.1 封装的意义

封装是C++面向对象三大特性之一，封装的意义：

*   将属性和行为作为一个整体，表现生活中的事物
*   将属性和行为加以权限控制

**封装意义一：**

 在设计类的时候，属性和行为写在一起，表现事物

**语法：** `class 类名{ 访问权限： 属性 / 行为 };`

**示例1：** 设计一个圆类，求[圆的周长](https://so.csdn.net/so/search?q=%E5%9C%86%E7%9A%84%E5%91%A8%E9%95%BF&spm=1001.2101.3001.7020)

**示例代码：**

```cpp
//圆周率
const double PI = 3.14;

//1、封装的意义
//将属性和行为作为一个整体，用来表现生活中的事物

//封装一个圆类，求圆的周长
//class代表设计一个类，后面跟着的是类名
class Circle
{
public:  //访问权限  公共的权限

	//属性
	int m_r;//半径

	//行为
	//获取到圆的周长
	double calculateZC()
	{
		//2 * pi  * r
		//获取圆的周长
		return  2 * PI * m_r;
	}
};

int main() {

	//通过圆类，创建圆的对象
	// c1就是一个具体的圆
	Circle c1;
	c1.m_r = 10; //给圆对象的半径 进行赋值操作

	//2 * pi * 10 = = 62.8
	cout << '圆的周长为： ' << c1.calculateZC() << endl;
	
	return 0;
}
```

**示例2：** 设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号

**示例2代码：**

```cpp
//学生类
class Student {
public:
	void setName(string name) {
		m_name = name;
	}
	void setID(int id) {
		m_id = id;
	}

	void showStudent() {
		cout << 'name:' << m_name << ' ID:' << m_id << endl;
	}
public:
	string m_name;
	int m_id;
};

int main() {

	Student stu;
	stu.setName('德玛西亚');
	stu.setID(250);
	stu.showStudent();

	return 0;
}

```

**封装意义二：**

类在设计时，可以把属性和行为放在不同的权限下，加以控制，[访问权限](https://so.csdn.net/so/search?q=%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90&spm=1001.2101.3001.7020)有三种：

1.  public 公共权限
2.  protected 保护权限
3.  private 私有权限

**示例：**

```cpp
//三种权限
//公共权限  public     类内可以访问  类外可以访问
//保护权限  protected  类内可以访问  类外不可以访问
//私有权限  private    类内可以访问  类外不可以访问

class Person
{
	//姓名  公共权限
public:
	string m_Name;

	//汽车  保护权限
protected:
	string m_Car;

	//银行卡密码  私有权限
private:
	int m_Password;

public:
	void func()
	{
		m_Name = '张三';
		m_Car = '拖拉机';
		m_Password = 123456;
	}
};

int main() {

	Person p;
	p.m_Name = '李四';
	//p.m_Car = '奔驰';  //保护权限类外访问不到
	//p.m_Password = 123; //私有权限类外访问不到

	return 0;
}
```

##### 1.1.2 struct和class区别

在C++中 struct和class唯一的**区别**就在于 **默认的访问权限不同**，区别：

*   struct 默认权限为公共
*   class 默认权限为私有

```cpp
class C1
{
	int  m_A; //默认是私有权限
};

struct C2
{
	int m_A;  //默认是公共权限
};

int main() {

	C1 c1;
	c1.m_A = 10; //错误，访问权限是私有

	C2 c2;
	c2.m_A = 10; //正确，访问权限是公共

	system('pause');

	return 0;
}
```

##### 1.1.3 成员属性设置为私有

**优点1：** 将所有成员属性设置为私有，可以自己控制读写权限

**优点2：** 对于写权限，我们可以检测数据的有效性

**示例：**

```cpp
class Person {
public:

	//姓名设置可读可写
	void setName(string name) {
		m_Name = name;
	}
	string getName()
	{
		return m_Name;
	}

	//获取年龄 
	int getAge() {
		return m_Age;
	}
	//设置年龄
	void setAge(int age) {
		if (age < 0 || age > 150) {
			cout << '你个老妖精!' << endl;
			return;
		}
		m_Age = age;
	}

	//情人设置为只写
	void setLover(string lover) {
		m_Lover = lover;
	}

private:
	string m_Name; //可读可写  姓名
	
	int m_Age; //只读  年龄

	string m_Lover; //只写  情人
};

int main() {

	Person p;
	//姓名设置
	p.setName('张三');
	cout << '姓名： ' << p.getName() << endl;

	//年龄设置
	p.setAge(50);
	cout << '年龄： ' << p.getAge() << endl;

	//情人设置
	p.setLover('苍井');
	//cout << '情人： ' << p.m_Lover << endl;  //只写属性，不可以读取

	return 0;
}
```

#### 1.2 对象的初始化和清理

*   生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全
*   C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://nickyoung0514.github.io/yblog.github.io/post/%E3%80%90C%2B%2B-he-xin-%E3%80%91-yi-wen-li-jie-C%2B%2B-mian-xiang-dui-xiang-%EF%BC%88-xiang-xi-%EF%BC%89.html">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/38165902?v=4">
<title>【C++核心】一文理解C++面向对象（详细）</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">【C++核心】一文理解C++面向对象（详细）</h1>
<div class="title-right">
    <a href="https://nickyoung0514.github.io/yblog.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/nickyoung0514/yblog.github.io/issues/2" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h4>文章目录</h4>
<ul>
<li>
<ul>
<li><a href="#__2">一. 类和对象</a></li>
<li>
<ul>
<li><a href="#11__16">1.1 封装</a></li>
<li>
<ul>
<li><a href="#111___17">1.1.1 封装的意义</a></li>
<li><a href="#112_structclass_163">1.1.2 struct和class区别</a></li>
<li><a href="#113__193">1.1.3 成员属性设置为私有</a></li>
</ul>
</li>
<li><a href="#12__260">1.2 对象的初始化和清理</a></li>
<li>
<ul>
<li><a href="#121__264">1.2.1 构造函数和析构函数</a></li>
<li><a href="#122__321">1.2.2 构造函数的分类及调用</a></li>
<li><a href="#123__404">1.2.3 拷贝构造函数调用时机</a></li>
<li><a href="#124__481">1.2.4 构造函数调用规则</a></li>
<li><a href="#125__556">1.2.5 深拷贝与浅拷贝</a></li>
<li><a href="#126__624">1.2.6 初始化列表</a></li>
<li><a href="#127__666">1.2.7 类对象作为类成员</a></li>
<li><a href="#128__744">1.2.8 静态成员</a></li>
</ul>
</li>
<li><a href="#13_Cthis_869">1.3 C++对象模型和this指针</a></li>
<li>
<ul>
<li><a href="#131__870">1.3.1 成员变量和成员函数分开存储</a></li>
<li><a href="#132_this_902">1.3.2 this指针概念</a></li>
<li><a href="#133__959">1.3.3 空指针访问成员函数</a></li>
<li><a href="#134_const_1003">1.3.4 const修饰成员函数</a></li>
</ul>
</li>
<li><a href="#14__1070">1.4 友元</a></li>
<li>
<ul>
<li><a href="#141__1089">1.4.1 全局函数做友元</a></li>
<li><a href="#142__1137">1.4.2 类做友元</a></li>
<li><a href="#143__1200">1.4.3 成员函数做友元</a></li>
</ul>
</li>
<li><a href="#15__1268">1.5 运算符重载</a></li>
<li>
<ul>
<li><a href="#151__1271">1.5.1 加号运算符重载</a></li>
<li><a href="#152__1341">1.5.2 左移运算符重载</a></li>
<li><a href="#153__1390">1.5.3 递增运算符重载</a></li>
<li><a href="#154__1456">1.5.4 赋值运算符重载</a></li>
<li><a href="#155__1549">1.5.5 关系运算符重载</a></li>
<li><a href="#156__1628">1.5.6 函数调用运算符重载</a></li>
</ul>
</li>
<li><a href="#16___1681">1.6 继承</a></li>
<li>
<ul>
<li><a href="#161__1686">1.6.1 继承的基本语法</a></li>
<li><a href="#162__1904">1.6.2 继承方式</a></li>
<li><a href="#163__2004">1.6.3 继承中的对象模型</a></li>
<li><a href="#164__2046">1.6.4 继承中构造和析构顺序</a></li>
<li><a href="#165__2097">1.6.5 继承同名成员处理方式</a></li>
<li><a href="#166__2170">1.6.6 继承同名静态成员处理方式</a></li>
<li><a href="#167__2250">1.6.7 多继承语法</a></li>
<li><a href="#168__2317">1.6.8 菱形继承</a></li>
</ul>
</li>
<li><a href="#17___2372">1.7 多态</a></li>
<li>
<ul>
<li><a href="#171__2373">1.7.1 多态的基本概念</a></li>
<li><a href="#172__2467">1.7.2 多态案例一-计算器类</a></li>
<li><a href="#173__2602">1.7.3 纯虚函数和抽象类</a></li>
<li><a href="#174__2657">1.7.4 多态案例二-制作饮品</a></li>
<li><a href="#175__2754">1.7.5 虚析构和纯虚析构</a></li>
<li><a href="#176__2866">1.7.6 多态案例三-电脑组装</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>一. 类和对象</h3>
<p>C++<a href="https://so.csdn.net/so/search?q=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1&amp;spm=1001.2101.3001.7020" rel="nofollow">面向对象</a>的三大特性为：封装、继承、多态</p>
<p>C++认为万事万物都皆为对象，对象上有其属性和行为</p>
<p><strong>例如：</strong></p>
<p>人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p>
<p>车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p>
<p>具有相同性质的对象，我们可以抽象称为类，人属于人类，车属于车类</p>
<h4>1.1 封装</h4>
<h5>1.1.1 封装的意义</h5>
<p>封装是C++面向对象三大特性之一，封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p><strong>封装意义一：</strong></p>
<p>在设计类的时候，属性和行为写在一起，表现事物</p>
<p><strong>语法：</strong> <code class="notranslate">class 类名{ 访问权限： 属性 / 行为 };</code></p>
<p><strong>示例1：</strong> 设计一个圆类，求<a href="https://so.csdn.net/so/search?q=%E5%9C%86%E7%9A%84%E5%91%A8%E9%95%BF&amp;spm=1001.2101.3001.7020" rel="nofollow">圆的周长</a></p>
<p><strong>示例代码：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-c"><span class="pl-c">//</span>圆周率</span>
<span class="pl-k">const</span> <span class="pl-k">double</span> PI = <span class="pl-c1">3.14</span>;

<span class="pl-c"><span class="pl-c">//</span>1、封装的意义</span>
<span class="pl-c"><span class="pl-c">//</span>将属性和行为作为一个整体，用来表现生活中的事物</span>

<span class="pl-c"><span class="pl-c">//</span>封装一个圆类，求圆的周长</span>
<span class="pl-c"><span class="pl-c">//</span>class代表设计一个类，后面跟着的是类名</span>
<span class="pl-k">class</span> <span class="pl-en">Circle</span>
{
<span class="pl-k">public:</span>  <span class="pl-c"><span class="pl-c">//</span>访问权限  公共的权限</span>

	<span class="pl-c"><span class="pl-c">//</span>属性</span>
	<span class="pl-k">int</span> m_r;<span class="pl-c"><span class="pl-c">//</span>半径</span>

	<span class="pl-c"><span class="pl-c">//</span>行为</span>
	<span class="pl-c"><span class="pl-c">//</span>获取到圆的周长</span>
	<span class="pl-k">double</span> <span class="pl-en">calculateZC</span>()
	{
		<span class="pl-c"><span class="pl-c">//</span>2 * pi  * r</span>
		<span class="pl-c"><span class="pl-c">//</span>获取圆的周长</span>
		<span class="pl-k">return</span>  <span class="pl-c1">2</span> * PI * m_r;
	}
};

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c"><span class="pl-c">//</span>通过圆类，创建圆的对象</span>
	<span class="pl-c"><span class="pl-c">//</span> c1就是一个具体的圆</span>
	Circle c1;
	c1.<span class="pl-smi">m_r</span> = <span class="pl-c1">10</span>; <span class="pl-c"><span class="pl-c">//</span>给圆对象的半径 进行赋值操作</span>

	<span class="pl-c"><span class="pl-c">//</span>2 * pi * 10 = = 62.8</span>
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>圆的周长为： <span class="pl-pds">"</span></span> &lt;&lt; c1.<span class="pl-c1">calculateZC</span>() &lt;&lt; endl;
	
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p><strong>示例2：</strong> 设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>
<p><strong>示例2代码：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-c"><span class="pl-c">//</span>学生类</span>
<span class="pl-k">class</span> <span class="pl-en">Student</span> {
<span class="pl-k">public:</span>
	<span class="pl-k">void</span> <span class="pl-en">setName</span>(string name) {
		m_name = name;
	}
	<span class="pl-k">void</span> <span class="pl-en">setID</span>(<span class="pl-k">int</span> id) {
		m_id = id;
	}

	<span class="pl-k">void</span> <span class="pl-en">showStudent</span>() {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>name:<span class="pl-pds">"</span></span> &lt;&lt; m_name &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> ID:<span class="pl-pds">"</span></span> &lt;&lt; m_id &lt;&lt; endl;
	}
<span class="pl-k">public:</span>
	string m_name;
	<span class="pl-k">int</span> m_id;
};

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	Student stu;
	stu.<span class="pl-c1">setName</span>(<span class="pl-s"><span class="pl-pds">"</span>德玛西亚<span class="pl-pds">"</span></span>);
	stu.<span class="pl-c1">setID</span>(<span class="pl-c1">250</span>);
	stu.<span class="pl-c1">showStudent</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}
</pre></div>
<p><strong>封装意义二：</strong></p>
<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制，<a href="https://so.csdn.net/so/search?q=%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90&amp;spm=1001.2101.3001.7020" rel="nofollow">访问权限</a>有三种：</p>
<ol>
<li>public 公共权限</li>
<li>protected 保护权限</li>
<li>private 私有权限</li>
</ol>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-c"><span class="pl-c">//</span>三种权限</span>
<span class="pl-c"><span class="pl-c">//</span>公共权限  public     类内可以访问  类外可以访问</span>
<span class="pl-c"><span class="pl-c">//</span>保护权限  protected  类内可以访问  类外不可以访问</span>
<span class="pl-c"><span class="pl-c">//</span>私有权限  private    类内可以访问  类外不可以访问</span>

<span class="pl-k">class</span> <span class="pl-en">Person</span>
{
	<span class="pl-c"><span class="pl-c">//</span>姓名  公共权限</span>
<span class="pl-k">public:</span>
	string m_Name;

	<span class="pl-c"><span class="pl-c">//</span>汽车  保护权限</span>
<span class="pl-k">protected:</span>
	string m_Car;

	<span class="pl-c"><span class="pl-c">//</span>银行卡密码  私有权限</span>
<span class="pl-k">private:</span>
	<span class="pl-k">int</span> m_Password;

<span class="pl-k">public:</span>
	<span class="pl-k">void</span> <span class="pl-en">func</span>()
	{
		m_Name = <span class="pl-s"><span class="pl-pds">"</span>张三<span class="pl-pds">"</span></span>;
		m_Car = <span class="pl-s"><span class="pl-pds">"</span>拖拉机<span class="pl-pds">"</span></span>;
		m_Password = <span class="pl-c1">123456</span>;
	}
};

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	Person p;
	p.<span class="pl-smi">m_Name</span> = <span class="pl-s"><span class="pl-pds">"</span>李四<span class="pl-pds">"</span></span>;
	<span class="pl-c"><span class="pl-c">//</span>p.m_Car = "奔驰";  //保护权限类外访问不到</span>
	<span class="pl-c"><span class="pl-c">//</span>p.m_Password = 123; //私有权限类外访问不到</span>

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h5>1.1.2 struct和class区别</h5>
<p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong>，区别：</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class 默认权限为私有</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">C1</span>
{
	<span class="pl-k">int</span>  m_A; <span class="pl-c"><span class="pl-c">//</span>默认是私有权限</span>
};

<span class="pl-k">struct</span> <span class="pl-en">C2</span>
{
	<span class="pl-k">int</span> m_A;  <span class="pl-c"><span class="pl-c">//</span>默认是公共权限</span>
};

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	C1 c1;
	c1.<span class="pl-smi">m_A</span> = <span class="pl-c1">10</span>; <span class="pl-c"><span class="pl-c">//</span>错误，访问权限是私有</span>

	C2 c2;
	c2.<span class="pl-smi">m_A</span> = <span class="pl-c1">10</span>; <span class="pl-c"><span class="pl-c">//</span>正确，访问权限是公共</span>

	<span class="pl-c1">system</span>(<span class="pl-s"><span class="pl-pds">"</span>pause<span class="pl-pds">"</span></span>);

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h5>1.1.3 成员属性设置为私有</h5>
<p><strong>优点1：</strong> 将所有成员属性设置为私有，可以自己控制读写权限</p>
<p><strong>优点2：</strong> 对于写权限，我们可以检测数据的有效性</p>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Person</span> {
<span class="pl-k">public:</span>

	<span class="pl-c"><span class="pl-c">//</span>姓名设置可读可写</span>
	<span class="pl-k">void</span> <span class="pl-en">setName</span>(string name) {
		m_Name = name;
	}
	string <span class="pl-en">getName</span>()
	{
		<span class="pl-k">return</span> m_Name;
	}

	<span class="pl-c"><span class="pl-c">//</span>获取年龄 </span>
	<span class="pl-k">int</span> <span class="pl-en">getAge</span>() {
		<span class="pl-k">return</span> m_Age;
	}
	<span class="pl-c"><span class="pl-c">//</span>设置年龄</span>
	<span class="pl-k">void</span> <span class="pl-en">setAge</span>(<span class="pl-k">int</span> age) {
		<span class="pl-k">if</span> (age &lt; <span class="pl-c1">0</span> || age &gt; <span class="pl-c1">150</span>) {
			cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>你个老妖精!<span class="pl-pds">"</span></span> &lt;&lt; endl;
			<span class="pl-k">return</span>;
		}
		m_Age = age;
	}

	<span class="pl-c"><span class="pl-c">//</span>情人设置为只写</span>
	<span class="pl-k">void</span> <span class="pl-en">setLover</span>(string lover) {
		m_Lover = lover;
	}

<span class="pl-k">private:</span>
	string m_Name; <span class="pl-c"><span class="pl-c">//</span>可读可写  姓名</span>
	
	<span class="pl-k">int</span> m_Age; <span class="pl-c"><span class="pl-c">//</span>只读  年龄</span>

	string m_Lover; <span class="pl-c"><span class="pl-c">//</span>只写  情人</span>
};

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	Person p;
	<span class="pl-c"><span class="pl-c">//</span>姓名设置</span>
	p.<span class="pl-c1">setName</span>(<span class="pl-s"><span class="pl-pds">"</span>张三<span class="pl-pds">"</span></span>);
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>姓名： <span class="pl-pds">"</span></span> &lt;&lt; p.<span class="pl-c1">getName</span>() &lt;&lt; endl;

	<span class="pl-c"><span class="pl-c">//</span>年龄设置</span>
	p.<span class="pl-c1">setAge</span>(<span class="pl-c1">50</span>);
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>年龄： <span class="pl-pds">"</span></span> &lt;&lt; p.<span class="pl-c1">getAge</span>() &lt;&lt; endl;

	<span class="pl-c"><span class="pl-c">//</span>情人设置</span>
	p.<span class="pl-c1">setLover</span>(<span class="pl-s"><span class="pl-pds">"</span>苍井<span class="pl-pds">"</span></span>);
	<span class="pl-c"><span class="pl-c">//</span>cout &lt;&lt; "情人： " &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span>

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h4>1.2 对象的初始化和清理</h4>
<ul>
<li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li>
</ul>
<h5>1.2.1 构造函数和析构函数</h5>
<p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题，一个对象或者变量没有初始状态，对其使用后果是未知，同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p><strong>构造函数语法：</strong><code class="notranslate">类名(){}</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code class="notranslate">~类名(){}</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号 ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Person</span>
{
<span class="pl-k">public:</span>
	<span class="pl-c"><span class="pl-c">//</span>构造函数</span>
	<span class="pl-en">Person</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Person的构造函数调用<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-c"><span class="pl-c">//</span>析构函数</span>
	<span class="pl-en">~Person</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Person的析构函数调用<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}

};

<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	Person p;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {
	
	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h5>1.2.2 构造函数的分类及调用</h5>
<p>两种分类方式：</p>
<p>按参数分为： 有参构造和无参构造</p>
<p>按类型分为： 普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>括号法</p>
<p>显示法</p>
<p>隐式转换法</p>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-c"><span class="pl-c">//</span>1、构造函数分类</span>
<span class="pl-c"><span class="pl-c">//</span> 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span>
<span class="pl-c"><span class="pl-c">//</span> 按照类型分类分为 普通构造和拷贝构造</span>

<span class="pl-k">class</span> <span class="pl-en">Person</span> {
<span class="pl-k">public:</span>
	<span class="pl-c"><span class="pl-c">//</span>无参（默认）构造函数</span>
	<span class="pl-en">Person</span>() {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>无参构造函数!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-c"><span class="pl-c">//</span>有参构造函数</span>
	<span class="pl-en">Person</span>(<span class="pl-k">int</span> a) {
		age = a;
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>有参构造函数!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-c"><span class="pl-c">//</span>拷贝构造函数</span>
	<span class="pl-en">Person</span>(<span class="pl-k">const</span> Person&amp; p) {
		age = p.<span class="pl-smi">age</span>;
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>拷贝构造函数!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-c"><span class="pl-c">//</span>析构函数</span>
	<span class="pl-en">~Person</span>() {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>析构函数!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
<span class="pl-k">public:</span>
	<span class="pl-k">int</span> age;
};

<span class="pl-c"><span class="pl-c">//</span>2、构造函数的调用</span>
<span class="pl-c"><span class="pl-c">//</span>调用无参构造函数</span>
<span class="pl-k">void</span> <span class="pl-en">test01</span>() {
	Person p; <span class="pl-c"><span class="pl-c">//</span>调用无参构造函数</span>
}

<span class="pl-c"><span class="pl-c">//</span>调用有参的构造函数</span>
<span class="pl-k">void</span> <span class="pl-en">test02</span>() {

	<span class="pl-c"><span class="pl-c">//</span>2.1  括号法，常用</span>
	Person <span class="pl-smi">p1</span>(<span class="pl-c1">10</span>);
	<span class="pl-c"><span class="pl-c">//</span>注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span>
	<span class="pl-c"><span class="pl-c">//</span>Person p2();</span>

	<span class="pl-c"><span class="pl-c">//</span>2.2 显式法</span>
	Person p2 = <span class="pl-c1">Person</span>(<span class="pl-c1">10</span>); 
	Person p3 = <span class="pl-c1">Person</span>(p2);
	<span class="pl-c"><span class="pl-c">//</span>Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span>

	<span class="pl-c"><span class="pl-c">//</span>2.3 隐式转换法</span>
	Person p4 = <span class="pl-c1">10</span>; <span class="pl-c"><span class="pl-c">//</span> Person p4 = Person(10); </span>
	Person p5 = p4; <span class="pl-c"><span class="pl-c">//</span> Person p5 = Person(p4); </span>

	<span class="pl-c"><span class="pl-c">//</span>注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span>
	<span class="pl-c"><span class="pl-c">//</span>Person p5(p4);</span>
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();
	<span class="pl-c"><span class="pl-c">//</span>test02();</span>
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h5>1.2.3 拷贝构造函数调用时机</h5>
<p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Person</span> {
<span class="pl-k">public:</span>
	<span class="pl-en">Person</span>() {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>无参构造函数!<span class="pl-pds">"</span></span> &lt;&lt; endl;
		<span class="pl-smi">mAge</span> = <span class="pl-c1">0</span>;
	}
	<span class="pl-en">Person</span>(<span class="pl-k">int</span> age) {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>有参构造函数!<span class="pl-pds">"</span></span> &lt;&lt; endl;
		<span class="pl-smi">mAge</span> = age;
	}
	<span class="pl-en">Person</span>(<span class="pl-k">const</span> Person&amp; p) {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>拷贝构造函数!<span class="pl-pds">"</span></span> &lt;&lt; endl;
		<span class="pl-smi">mAge</span> = p.<span class="pl-smi">mAge</span>;
	}
	<span class="pl-c"><span class="pl-c">//</span>析构函数在释放内存之前调用</span>
	<span class="pl-en">~Person</span>() {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>析构函数!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
<span class="pl-k">public:</span>
	<span class="pl-k">int</span> <span class="pl-smi">mAge</span>;
};

<span class="pl-c"><span class="pl-c">//</span>1. 使用一个已经创建完毕的对象来初始化一个新对象</span>
<span class="pl-k">void</span> <span class="pl-en">test01</span>() {

	Person <span class="pl-smi">man</span>(<span class="pl-c1">100</span>); <span class="pl-c"><span class="pl-c">//</span>p对象已经创建完毕</span>
	Person <span class="pl-smi">newman</span>(man); <span class="pl-c"><span class="pl-c">//</span>调用拷贝构造函数</span>
	Person newman2 = man; <span class="pl-c"><span class="pl-c">//</span>拷贝构造</span>

	<span class="pl-c"><span class="pl-c">//</span>Person newman3;</span>
	<span class="pl-c"><span class="pl-c">//</span>newman3 = man; //不是调用拷贝构造函数，赋值操作</span>
}

<span class="pl-c"><span class="pl-c">//</span>2. 值传递的方式给函数参数传值</span>
<span class="pl-c"><span class="pl-c">//</span>相当于Person p1 = p;</span>
<span class="pl-k">void</span> <span class="pl-en">doWork</span>(Person p1) {}
<span class="pl-k">void</span> <span class="pl-en">test02</span>() {
	Person p; <span class="pl-c"><span class="pl-c">//</span>无参构造函数</span>
	<span class="pl-c1">doWork</span>(p);
}

<span class="pl-c"><span class="pl-c">//</span>3. 以值方式返回局部对象</span>
Person <span class="pl-en">doWork2</span>()
{
	Person p1;
	cout &lt;&lt; (<span class="pl-k">int</span> *)&amp;p1 &lt;&lt; endl;
	<span class="pl-k">return</span> p1;
}

<span class="pl-k">void</span> <span class="pl-en">test03</span>()
{
	Person p = <span class="pl-c1">doWork2</span>();
	cout &lt;&lt; (<span class="pl-k">int</span> *)&amp;p &lt;&lt; endl;
}


<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c"><span class="pl-c">//</span>test01();</span>
	<span class="pl-c"><span class="pl-c">//</span>test02();</span>
	<span class="pl-c1">test03</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h5>1.2.4 构造函数调用规则</h5>
<p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li>
<p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</p>
</li>
<li>
<p>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p>
</li>
</ul>
<p>示例：</p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Person</span> {
<span class="pl-k">public:</span>
	<span class="pl-c"><span class="pl-c">//</span>无参（默认）构造函数</span>
	<span class="pl-en">Person</span>() {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>无参构造函数!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-c"><span class="pl-c">//</span>有参构造函数</span>
	<span class="pl-en">Person</span>(<span class="pl-k">int</span> a) {
		age = a;
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>有参构造函数!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-c"><span class="pl-c">//</span>拷贝构造函数</span>
	<span class="pl-en">Person</span>(<span class="pl-k">const</span> Person&amp; p) {
		age = p.<span class="pl-smi">age</span>;
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>拷贝构造函数!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-c"><span class="pl-c">//</span>析构函数</span>
	<span class="pl-en">~Person</span>() {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>析构函数!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
<span class="pl-k">public:</span>
	<span class="pl-k">int</span> age;
};

<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	Person <span class="pl-smi">p1</span>(<span class="pl-c1">18</span>);
	<span class="pl-c"><span class="pl-c">//</span>如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span>
	Person <span class="pl-smi">p2</span>(p1);

	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>p2的年龄为： <span class="pl-pds">"</span></span> &lt;&lt; p2.<span class="pl-smi">age</span> &lt;&lt; endl;
}

<span class="pl-k">void</span> <span class="pl-en">test02</span>()
{
	<span class="pl-c"><span class="pl-c">//</span>如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span>
	Person p1; <span class="pl-c"><span class="pl-c">//</span>此时如果用户自己没有提供默认构造，会出错</span>
	Person <span class="pl-smi">p2</span>(<span class="pl-c1">10</span>); <span class="pl-c"><span class="pl-c">//</span>用户提供的有参</span>
	Person <span class="pl-smi">p3</span>(p2); <span class="pl-c"><span class="pl-c">//</span>此时如果用户没有提供拷贝构造，编译器会提供</span>

	<span class="pl-c"><span class="pl-c">//</span>如果用户提供拷贝构造，编译器不会提供其他构造函数</span>
	Person p4; <span class="pl-c"><span class="pl-c">//</span>此时如果用户自己没有提供默认构造，会出错</span>
	Person <span class="pl-smi">p5</span>(<span class="pl-c1">10</span>); <span class="pl-c"><span class="pl-c">//</span>此时如果用户自己没有提供有参，会出错</span>
	Person <span class="pl-smi">p6</span>(p5); <span class="pl-c"><span class="pl-c">//</span>用户自己提供拷贝构造</span>
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h5>1.2.5 深拷贝与浅拷贝</h5>
<p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Person</span> {
<span class="pl-k">public:</span>
	<span class="pl-c"><span class="pl-c">//</span>无参（默认）构造函数</span>
	<span class="pl-en">Person</span>() {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>无参构造函数!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-c"><span class="pl-c">//</span>有参构造函数</span>
	<span class="pl-en">Person</span>(<span class="pl-k">int</span> age ,<span class="pl-k">int</span> height) {
		
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>有参构造函数!<span class="pl-pds">"</span></span> &lt;&lt; endl;

		m_age = age;
		m_height = <span class="pl-k">new</span> <span class="pl-c1">int</span>(height);
		
	}
	<span class="pl-c"><span class="pl-c">//</span>拷贝构造函数  </span>
	<span class="pl-en">Person</span>(<span class="pl-k">const</span> Person&amp; p) {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>拷贝构造函数!<span class="pl-pds">"</span></span> &lt;&lt; endl;
		<span class="pl-c"><span class="pl-c">//</span>如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span>
		m_age = p.<span class="pl-smi">m_age</span>;
		m_height = <span class="pl-k">new</span> <span class="pl-c1">int</span>(*p.<span class="pl-smi">m_height</span>);
		
	}

	<span class="pl-c"><span class="pl-c">//</span>析构函数</span>
	<span class="pl-en">~Person</span>() {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>析构函数!<span class="pl-pds">"</span></span> &lt;&lt; endl;
		<span class="pl-k">if</span> (m_height != <span class="pl-c1">NULL</span>)
		{
			<span class="pl-k">delete</span> m_height;
		}
	}
<span class="pl-k">public:</span>
	<span class="pl-k">int</span> m_age;
	<span class="pl-k">int</span>* m_height;
};

<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	Person <span class="pl-smi">p1</span>(<span class="pl-c1">18</span>, <span class="pl-c1">180</span>);

	Person <span class="pl-smi">p2</span>(p1);

	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>p1的年龄： <span class="pl-pds">"</span></span> &lt;&lt; p1.<span class="pl-smi">m_age</span> &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> 身高： <span class="pl-pds">"</span></span> &lt;&lt; *p1.<span class="pl-smi">m_height</span> &lt;&lt; endl;

	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>p2的年龄： <span class="pl-pds">"</span></span> &lt;&lt; p2.<span class="pl-smi">m_age</span> &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> 身高： <span class="pl-pds">"</span></span> &lt;&lt; *p2.<span class="pl-smi">m_height</span> &lt;&lt; endl;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<blockquote>
<p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>
</blockquote>
<h5>1.2.6 初始化列表</h5>
<p><strong>作用：</strong></p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p><strong>语法：</strong> <code class="notranslate">构造函数()：属性1(值1),属性2（值2）... {}</code></p>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Person</span> {
<span class="pl-k">public:</span>

	传统方式初始化
	<span class="pl-c"><span class="pl-c">//</span>Person(int a, int b, int c) {</span>
	<span class="pl-c"><span class="pl-c">//</span>	m_A = a;</span>
	<span class="pl-c"><span class="pl-c">//</span>	m_B = b;</span>
	<span class="pl-c"><span class="pl-c">//</span>	m_C = c;</span>
	<span class="pl-c"><span class="pl-c">//</span>}</span>

	<span class="pl-c"><span class="pl-c">//</span>初始化列表方式初始化</span>
	<span class="pl-en">Person</span>(<span class="pl-k">int</span> a, <span class="pl-k">int</span> b, <span class="pl-k">int</span> c) :m_A(a), m_B(b), m_C(c) {}
	<span class="pl-k">void</span> <span class="pl-en">PrintPerson</span>() {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>mA:<span class="pl-pds">"</span></span> &lt;&lt; m_A &lt;&lt; endl;
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>mB:<span class="pl-pds">"</span></span> &lt;&lt; m_B &lt;&lt; endl;
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>mC:<span class="pl-pds">"</span></span> &lt;&lt; m_C &lt;&lt; endl;
	}
<span class="pl-k">private:</span>
	<span class="pl-k">int</span> m_A;
	<span class="pl-k">int</span> m_B;
	<span class="pl-k">int</span> m_C;
};

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	Person <span class="pl-smi">p</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>);
	p.<span class="pl-c1">PrintPerson</span>();
	
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h5>1.2.7 类对象作为类成员</h5>
<p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>
<p>例如：</p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">A</span> {}<span class="pl-ii"></span>
<span class="pl-k">class</span> <span class="pl-en">B</span>
{
    A a；
}<span class="pl-ii"></span></pre></div>
<p>B类中有对象A作为成员，A为对象成员，那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Phone</span>
{
<span class="pl-k">public:</span>
	<span class="pl-en">Phone</span>(string name)
	{
		m_PhoneName = name;
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Phone构造<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}

	<span class="pl-en">~Phone</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Phone析构<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	string m_PhoneName;

};

<span class="pl-k">class</span> <span class="pl-en">Person</span>
{
<span class="pl-k">public:</span>

	<span class="pl-c"><span class="pl-c">//</span>初始化列表可以告诉编译器调用哪一个构造函数</span>
	<span class="pl-en">Person</span>(string name, string pName) :m_Name(name), m_Phone(pName)
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Person构造<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}

	<span class="pl-en">~Person</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Person析构<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}

	<span class="pl-k">void</span> <span class="pl-en">playGame</span>()
	{
		cout &lt;&lt; m_Name &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> 使用<span class="pl-pds">"</span></span> &lt;&lt; m_Phone.<span class="pl-smi">m_PhoneName</span> &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> 牌手机! <span class="pl-pds">"</span></span> &lt;&lt; endl;
	}

	string m_Name;
	Phone m_Phone;

};
<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	<span class="pl-c"><span class="pl-c">//</span>当类中成员是其他类对象时，我们称该成员为 对象成员</span>
	<span class="pl-c"><span class="pl-c">//</span>构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span>
	<span class="pl-c"><span class="pl-c">//</span>析构顺序与构造相反</span>
	Person <span class="pl-smi">p</span>(<span class="pl-s"><span class="pl-pds">"</span>张三<span class="pl-pds">"</span></span> , <span class="pl-s"><span class="pl-pds">"</span>苹果X<span class="pl-pds">"</span></span>);
	p.<span class="pl-c1">playGame</span>();

}


<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h5>1.2.8 静态成员</h5>
<p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li>静态成员变量
<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
</li>
<li>静态成员函数
<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p><strong>示例1 ：</strong> 静态成员变量</p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Person</span>
{
	
<span class="pl-k">public:</span>

	<span class="pl-k">static</span> <span class="pl-k">int</span> m_A; <span class="pl-c"><span class="pl-c">//</span>静态成员变量</span>

	<span class="pl-c"><span class="pl-c">//</span>静态成员变量特点：</span>
	<span class="pl-c"><span class="pl-c">//</span>1 在编译阶段分配内存</span>
	<span class="pl-c"><span class="pl-c">//</span>2 类内声明，类外初始化</span>
	<span class="pl-c"><span class="pl-c">//</span>3 所有对象共享同一份数据</span>

<span class="pl-k">private:</span>
	<span class="pl-k">static</span> <span class="pl-k">int</span> m_B; <span class="pl-c"><span class="pl-c">//</span>静态成员变量也是有访问权限的</span>
};
<span class="pl-k">int</span> Person::m_A = <span class="pl-c1">10</span>;
<span class="pl-k">int</span> Person::m_B = <span class="pl-c1">10</span>;

<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	<span class="pl-c"><span class="pl-c">//</span>静态成员变量两种访问方式</span>

	<span class="pl-c"><span class="pl-c">//</span>1、通过对象</span>
	Person p1;
	p1.<span class="pl-smi">m_A</span> = <span class="pl-c1">100</span>;
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>p1.m_A = <span class="pl-pds">"</span></span> &lt;&lt; p1.<span class="pl-smi">m_A</span> &lt;&lt; endl;

	Person p2;
	p2.<span class="pl-smi">m_A</span> = <span class="pl-c1">200</span>;
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>p1.m_A = <span class="pl-pds">"</span></span> &lt;&lt; p1.<span class="pl-smi">m_A</span> &lt;&lt; endl; <span class="pl-c"><span class="pl-c">//</span>共享同一份数据</span>
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>p2.m_A = <span class="pl-pds">"</span></span> &lt;&lt; p2.<span class="pl-smi">m_A</span> &lt;&lt; endl;

	<span class="pl-c"><span class="pl-c">//</span>2、通过类名</span>
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>m_A = <span class="pl-pds">"</span></span> &lt;&lt; Person::m_A &lt;&lt; endl;


	<span class="pl-c"><span class="pl-c">//</span>cout &lt;&lt; "m_B = " &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span>
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p><strong>示例2：</strong> 静态成员函数</p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Person</span>
{

<span class="pl-k">public:</span>

	<span class="pl-c"><span class="pl-c">//</span>静态成员函数特点：</span>
	<span class="pl-c"><span class="pl-c">//</span>1 程序共享一个函数</span>
	<span class="pl-c"><span class="pl-c">//</span>2 静态成员函数只能访问静态成员变量</span>
	
	<span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">func</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>func调用<span class="pl-pds">"</span></span> &lt;&lt; endl;
		m_A = <span class="pl-c1">100</span>;
		<span class="pl-c"><span class="pl-c">//</span>m_B = 100; //错误，不可以访问非静态成员变量</span>
	}

	<span class="pl-k">static</span> <span class="pl-k">int</span> m_A; <span class="pl-c"><span class="pl-c">//</span>静态成员变量</span>
	<span class="pl-k">int</span> m_B; <span class="pl-c"><span class="pl-c">//</span> </span>
<span class="pl-k">private:</span>

	<span class="pl-c"><span class="pl-c">//</span>静态成员函数也是有访问权限的</span>
	<span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">func2</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>func2调用<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
};
<span class="pl-k">int</span> Person::m_A = <span class="pl-c1">10</span>;


<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	<span class="pl-c"><span class="pl-c">//</span>静态成员变量两种访问方式</span>

	<span class="pl-c"><span class="pl-c">//</span>1、通过对象</span>
	Person p1;
	p1.<span class="pl-c1">func</span>();

	<span class="pl-c"><span class="pl-c">//</span>2、通过类名</span>
	<span class="pl-c1">Person::func</span>();


	<span class="pl-c"><span class="pl-c">//</span>Person::func2(); //私有权限访问不到</span>
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();

	<span class="pl-c1">system</span>(<span class="pl-s"><span class="pl-pds">"</span>pause<span class="pl-pds">"</span></span>);

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h4>1.3 C++对象模型和this指针</h4>
<h5>1.3.1 成员变量和成员函数分开存储</h5>
<p>在C++中，类内的成员变量和成员函数分开存储，只有非静态成员变量才属于类的对象上</p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Person</span> {
<span class="pl-k">public:</span>
	<span class="pl-en">Person</span>() {
		<span class="pl-smi">mA</span> = <span class="pl-c1">0</span>;
	}
	<span class="pl-c"><span class="pl-c">//</span>非静态成员变量占对象空间</span>
	<span class="pl-k">int</span> <span class="pl-smi">mA</span>;
	<span class="pl-c"><span class="pl-c">//</span>静态成员变量不占对象空间</span>
	<span class="pl-k">static</span> <span class="pl-k">int</span> <span class="pl-smi">mB</span>; 
	<span class="pl-c"><span class="pl-c">//</span>函数也不占对象空间，所有函数共享一个函数实例</span>
	<span class="pl-k">void</span> <span class="pl-en">func</span>() {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>mA:<span class="pl-pds">"</span></span> &lt;&lt; <span class="pl-c1">this</span>-&gt;<span class="pl-smi">mA</span> &lt;&lt; endl;
	}
	<span class="pl-c"><span class="pl-c">//</span>静态成员函数也不占对象空间</span>
	<span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">sfunc</span>() {
	}
};

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	cout &lt;&lt; <span class="pl-k">sizeof</span>(Person) &lt;&lt; endl;

	<span class="pl-c1">system</span>(<span class="pl-s"><span class="pl-pds">"</span>pause<span class="pl-pds">"</span></span>);

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h5>1.3.2 this指针概念</h5>
<p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li>当形参和成员变量同名时，可用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Person</span>
{
<span class="pl-k">public:</span>

	<span class="pl-en">Person</span>(<span class="pl-k">int</span> age)
	{
		<span class="pl-c"><span class="pl-c">//</span>1、当形参和成员变量同名时，可用this指针来区分</span>
		<span class="pl-c1">this</span>-&gt;<span class="pl-smi">age</span> = age;
	}

	Person&amp; <span class="pl-en">PersonAddPerson</span>(Person p)
	{
		<span class="pl-c1">this</span>-&gt;<span class="pl-smi">age</span> += p.<span class="pl-smi">age</span>;
		<span class="pl-c"><span class="pl-c">//</span>返回对象本身</span>
		<span class="pl-k">return</span> *<span class="pl-c1">this</span>;
	}

	<span class="pl-k">int</span> age;
};

<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	Person <span class="pl-smi">p1</span>(<span class="pl-c1">10</span>);
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>p1.age = <span class="pl-pds">"</span></span> &lt;&lt; p1.<span class="pl-smi">age</span> &lt;&lt; endl;

	Person <span class="pl-smi">p2</span>(<span class="pl-c1">10</span>);
	p2.<span class="pl-c1">PersonAddPerson</span>(p1).<span class="pl-c1">PersonAddPerson</span>(p1).<span class="pl-c1">PersonAddPerson</span>(p1);
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>p2.age = <span class="pl-pds">"</span></span> &lt;&lt; p2.<span class="pl-smi">age</span> &lt;&lt; endl;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h5>1.3.3 空指针访问成员函数</h5>
<p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-c"><span class="pl-c">//</span>空指针访问成员函数</span>
<span class="pl-k">class</span> <span class="pl-en">Person</span> {
<span class="pl-k">public:</span>

	<span class="pl-k">void</span> <span class="pl-en">ShowClassName</span>() {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>我是Person类!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}

	<span class="pl-k">void</span> <span class="pl-en">ShowPerson</span>() {
		<span class="pl-k">if</span> (<span class="pl-c1">this</span> == <span class="pl-c1">NULL</span>) {
			<span class="pl-k">return</span>;
		}
		cout &lt;&lt; <span class="pl-smi">mAge</span> &lt;&lt; endl;
	}

<span class="pl-k">public:</span>
	<span class="pl-k">int</span> <span class="pl-smi">mAge</span>;
};

<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	Person * p = <span class="pl-c1">NULL</span>;
	p-&gt;<span class="pl-c1">ShowClassName</span>(); <span class="pl-c"><span class="pl-c">//</span>空指针，可以调用成员函数</span>
	p-&gt;<span class="pl-c1">ShowPerson</span>();  <span class="pl-c"><span class="pl-c">//</span>但是如果成员函数中用到了this指针，就不可以了</span>
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h5>1.3.4 const修饰成员函数</h5>
<p><strong>常函数：</strong></p>
<ul>
<li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象：</strong></p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Person</span> {
<span class="pl-k">public:</span>
	<span class="pl-en">Person</span>() {
		m_A = <span class="pl-c1">0</span>;
		m_B = <span class="pl-c1">0</span>;
	}

	<span class="pl-c"><span class="pl-c">//</span>this指针的本质是一个指针常量，指针的指向不可修改</span>
	<span class="pl-c"><span class="pl-c">//</span>如果想让指针指向的值也不可以修改，需要声明常函数</span>
	<span class="pl-k">void</span> <span class="pl-en">ShowPerson</span>() <span class="pl-k">const</span> {
		<span class="pl-c"><span class="pl-c">//</span>const Type* const pointer;</span>
		<span class="pl-c"><span class="pl-c">//</span>this = NULL; //不能修改指针的指向 Person* const this;</span>
		<span class="pl-c"><span class="pl-c">//</span>this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span>

		<span class="pl-c"><span class="pl-c">//</span>const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span>
		<span class="pl-c1">this</span>-&gt;<span class="pl-smi">m_B</span> = <span class="pl-c1">100</span>;
	}

	<span class="pl-k">void</span> <span class="pl-en">MyFunc</span>() <span class="pl-k">const</span> {
		<span class="pl-c"><span class="pl-c">//</span>mA = 10000;</span>
	}

<span class="pl-k">public:</span>
	<span class="pl-k">int</span> m_A;
	<span class="pl-k">mutable</span> <span class="pl-k">int</span> m_B; <span class="pl-c"><span class="pl-c">//</span>可修改 可变的</span>
};


<span class="pl-c"><span class="pl-c">//</span>const修饰对象  常对象</span>
<span class="pl-k">void</span> <span class="pl-en">test01</span>() {

	<span class="pl-k">const</span> Person person; <span class="pl-c"><span class="pl-c">//</span>常量对象  </span>
	cout &lt;&lt; person.<span class="pl-smi">m_A</span> &lt;&lt; endl;
	<span class="pl-c"><span class="pl-c">//</span>person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span>
	person.<span class="pl-smi">m_B</span> = <span class="pl-c1">100</span>; <span class="pl-c"><span class="pl-c">//</span>但是常对象可以修改mutable修饰成员变量</span>

	<span class="pl-c"><span class="pl-c">//</span>常对象访问成员函数</span>
	person.<span class="pl-c1">MyFunc</span>(); <span class="pl-c"><span class="pl-c">//</span>常对象不能调用const的函数</span>

}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h4>1.4 友元</h4>
<p>生活中你的家有客厅(Public)，有你的卧室(Private)</p>
<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>
<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>
<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>
<p>友元的关键字为 friend</p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h5>1.4.1 全局函数做友元</h5>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Building</span>
{
	<span class="pl-c"><span class="pl-c">//</span>告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span>
	<span class="pl-k">friend</span> <span class="pl-k">void</span> <span class="pl-en">goodGay</span>(Building * building);

<span class="pl-k">public:</span>

	<span class="pl-en">Building</span>()
	{
		<span class="pl-c1">this</span>-&gt;<span class="pl-smi">m_SittingRoom</span> = <span class="pl-s"><span class="pl-pds">"</span>客厅<span class="pl-pds">"</span></span>;
		<span class="pl-c1">this</span>-&gt;<span class="pl-smi">m_BedRoom</span> = <span class="pl-s"><span class="pl-pds">"</span>卧室<span class="pl-pds">"</span></span>;
	}


<span class="pl-k">public:</span>
	string m_SittingRoom; <span class="pl-c"><span class="pl-c">//</span>客厅</span>

<span class="pl-k">private:</span>
	string m_BedRoom; <span class="pl-c"><span class="pl-c">//</span>卧室</span>
};


<span class="pl-k">void</span> <span class="pl-en">goodGay</span>(Building * building)
{
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>好基友正在访问： <span class="pl-pds">"</span></span> &lt;&lt; building-&gt;<span class="pl-smi">m_SittingRoom</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>好基友正在访问： <span class="pl-pds">"</span></span> &lt;&lt; building-&gt;<span class="pl-smi">m_BedRoom</span> &lt;&lt; endl;
}


<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	Building b;
	<span class="pl-c1">goodGay</span>(&amp;b);
}

<span class="pl-k">int</span> <span class="pl-en">main</span>(){

	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h5>1.4.2 类做友元</h5>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Building</span>;
<span class="pl-k">class</span> <span class="pl-en">goodGay</span>
{
<span class="pl-k">public:</span>

	<span class="pl-en">goodGay</span>();
	<span class="pl-k">void</span> <span class="pl-en">visit</span>();

<span class="pl-k">private:</span>
	Building *building;
};


<span class="pl-k">class</span> <span class="pl-en">Building</span>
{
	<span class="pl-c"><span class="pl-c">//</span>告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span>
	<span class="pl-k">friend</span> <span class="pl-k">class</span> <span class="pl-en">goodGay</span>;

<span class="pl-k">public:</span>
	<span class="pl-en">Building</span>();

<span class="pl-k">public:</span>
	string m_SittingRoom; <span class="pl-c"><span class="pl-c">//</span>客厅</span>
<span class="pl-k">private:</span>
	string m_BedRoom;<span class="pl-c"><span class="pl-c">//</span>卧室</span>
};

<span class="pl-en">Building::Building</span>()
{
	<span class="pl-c1">this</span>-&gt;<span class="pl-smi">m_SittingRoom</span> = <span class="pl-s"><span class="pl-pds">"</span>客厅<span class="pl-pds">"</span></span>;
	<span class="pl-c1">this</span>-&gt;<span class="pl-smi">m_BedRoom</span> = <span class="pl-s"><span class="pl-pds">"</span>卧室<span class="pl-pds">"</span></span>;
}

<span class="pl-en">goodGay::goodGay</span>()
{
	building = <span class="pl-k">new</span> Building;
}

<span class="pl-k">void</span> <span class="pl-en">goodGay::visit</span>()
{
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>好基友正在访问<span class="pl-pds">"</span></span> &lt;&lt; building-&gt;<span class="pl-smi">m_SittingRoom</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>好基友正在访问<span class="pl-pds">"</span></span> &lt;&lt; building-&gt;<span class="pl-smi">m_BedRoom</span> &lt;&lt; endl;
}

<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	goodGay gg;
	gg.<span class="pl-c1">visit</span>();

}

<span class="pl-k">int</span> <span class="pl-en">main</span>(){

	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h5>1.4.3 成员函数做友元</h5>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Building</span>;
<span class="pl-k">class</span> <span class="pl-en">goodGay</span>
{
<span class="pl-k">public:</span>

	<span class="pl-en">goodGay</span>();
	<span class="pl-k">void</span> <span class="pl-en">visit</span>(); <span class="pl-c"><span class="pl-c">//</span>只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span>
	<span class="pl-k">void</span> <span class="pl-en">visit2</span>(); 

<span class="pl-k">private:</span>
	Building *building;
};


<span class="pl-k">class</span> <span class="pl-en">Building</span>
{
	<span class="pl-c"><span class="pl-c">//</span>告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span>
	<span class="pl-k">friend</span> <span class="pl-k">void</span> <span class="pl-en">goodGay::visit</span>();

<span class="pl-k">public:</span>
	<span class="pl-en">Building</span>();

<span class="pl-k">public:</span>
	string m_SittingRoom; <span class="pl-c"><span class="pl-c">//</span>客厅</span>
<span class="pl-k">private:</span>
	string m_BedRoom;<span class="pl-c"><span class="pl-c">//</span>卧室</span>
};

<span class="pl-en">Building::Building</span>()
{
	<span class="pl-c1">this</span>-&gt;<span class="pl-smi">m_SittingRoom</span> = <span class="pl-s"><span class="pl-pds">"</span>客厅<span class="pl-pds">"</span></span>;
	<span class="pl-c1">this</span>-&gt;<span class="pl-smi">m_BedRoom</span> = <span class="pl-s"><span class="pl-pds">"</span>卧室<span class="pl-pds">"</span></span>;
}

<span class="pl-en">goodGay::goodGay</span>()
{
	building = <span class="pl-k">new</span> Building;
}

<span class="pl-k">void</span> <span class="pl-en">goodGay::visit</span>()
{
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>好基友正在访问<span class="pl-pds">"</span></span> &lt;&lt; building-&gt;<span class="pl-smi">m_SittingRoom</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>好基友正在访问<span class="pl-pds">"</span></span> &lt;&lt; building-&gt;<span class="pl-smi">m_BedRoom</span> &lt;&lt; endl;
}

<span class="pl-k">void</span> <span class="pl-en">goodGay::visit2</span>()
{
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>好基友正在访问<span class="pl-pds">"</span></span> &lt;&lt; building-&gt;<span class="pl-smi">m_SittingRoom</span> &lt;&lt; endl;
	<span class="pl-c"><span class="pl-c">//</span>cout &lt;&lt; "好基友正在访问" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span>
}

<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	goodGay  gg;
	gg.<span class="pl-c1">visit</span>();

}

<span class="pl-k">int</span> <span class="pl-en">main</span>(){
    
	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h4>1.5 运算符重载</h4>
<p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h5>1.5.1 加号运算符重载</h5>
<p>作用：实现两个自定义数据类型相加的运算</p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Person</span> {
<span class="pl-k">public:</span>
	<span class="pl-en">Person</span>() {};
	<span class="pl-en">Person</span>(<span class="pl-k">int</span> a, <span class="pl-k">int</span> b)
	{
		<span class="pl-c1">this</span>-&gt;<span class="pl-smi">m_A</span> = a;
		<span class="pl-c1">this</span>-&gt;<span class="pl-smi">m_B</span> = b;
	}
	<span class="pl-c"><span class="pl-c">//</span>成员函数实现 + 号运算符重载</span>
	Person <span class="pl-k">operator</span>+(<span class="pl-k">const</span> Person&amp; p) {
		Person temp;
		temp.<span class="pl-smi">m_A</span> = <span class="pl-c1">this</span>-&gt;<span class="pl-smi">m_A</span> + p.<span class="pl-smi">m_A</span>;
		temp.<span class="pl-smi">m_B</span> = <span class="pl-c1">this</span>-&gt;<span class="pl-smi">m_B</span> + p.<span class="pl-smi">m_B</span>;
		<span class="pl-k">return</span> temp;
	}

<span class="pl-k">public:</span>
	<span class="pl-k">int</span> m_A;
	<span class="pl-k">int</span> m_B;
};

<span class="pl-c"><span class="pl-c">//</span>全局函数实现 + 号运算符重载</span>
<span class="pl-c"><span class="pl-c">//</span>Person operator+(const Person&amp; p1, const Person&amp; p2) {</span>
<span class="pl-c"><span class="pl-c">//</span>	Person temp(0, 0);</span>
<span class="pl-c"><span class="pl-c">//</span>	temp.m_A = p1.m_A + p2.m_A;</span>
<span class="pl-c"><span class="pl-c">//</span>	temp.m_B = p1.m_B + p2.m_B;</span>
<span class="pl-c"><span class="pl-c">//</span>	return temp;</span>
<span class="pl-c"><span class="pl-c">//</span>}</span>

<span class="pl-c"><span class="pl-c">//</span>运算符重载 可以发生函数重载 </span>
Person <span class="pl-k">operator</span>+(<span class="pl-k">const</span> Person&amp; p2, <span class="pl-k">int</span> val)  
{
	Person temp;
	temp.<span class="pl-smi">m_A</span> = p2.<span class="pl-smi">m_A</span> + val;
	temp.<span class="pl-smi">m_B</span> = p2.<span class="pl-smi">m_B</span> + val;
	<span class="pl-k">return</span> temp;
}

<span class="pl-k">void</span> <span class="pl-en">test</span>() {

	Person <span class="pl-smi">p1</span>(<span class="pl-c1">10</span>, <span class="pl-c1">10</span>);
	Person <span class="pl-smi">p2</span>(<span class="pl-c1">20</span>, <span class="pl-c1">20</span>);

	<span class="pl-c"><span class="pl-c">//</span>成员函数方式</span>
	Person p3 = p2 + p1;  <span class="pl-c"><span class="pl-c">//</span>相当于 p2.operaor+(p1)</span>
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>mA:<span class="pl-pds">"</span></span> &lt;&lt; p3.<span class="pl-smi">m_A</span> &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> mB:<span class="pl-pds">"</span></span> &lt;&lt; p3.<span class="pl-smi">m_B</span> &lt;&lt; endl;


	Person p4 = p3 + <span class="pl-c1">10</span>; <span class="pl-c"><span class="pl-c">//</span>相当于 operator+(p3,10)</span>
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>mA:<span class="pl-pds">"</span></span> &lt;&lt; p4.<span class="pl-smi">m_A</span> &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> mB:<span class="pl-pds">"</span></span> &lt;&lt; p4.<span class="pl-smi">m_B</span> &lt;&lt; endl;

}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<blockquote>
<p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>
</blockquote>
<blockquote>
<p>总结2：不要滥用运算符重载</p>
</blockquote>
<h5>1.5.2 左移运算符重载</h5>
<p>作用：可以输出自定义数据类型</p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Person</span> {
	<span class="pl-k">friend</span> ostream&amp; <span class="pl-k">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);

<span class="pl-k">public:</span>

	<span class="pl-en">Person</span>(<span class="pl-k">int</span> a, <span class="pl-k">int</span> b)
	{
		<span class="pl-c1">this</span>-&gt;<span class="pl-smi">m_A</span> = a;
		<span class="pl-c1">this</span>-&gt;<span class="pl-smi">m_B</span> = b;
	}

	<span class="pl-c"><span class="pl-c">//</span>成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span>
	<span class="pl-c"><span class="pl-c">//</span>void operator&lt;&lt;(Person&amp; p){</span>
	<span class="pl-c"><span class="pl-c">//</span>}</span>

<span class="pl-k">private:</span>
	<span class="pl-k">int</span> m_A;
	<span class="pl-k">int</span> m_B;
};

<span class="pl-c"><span class="pl-c">//</span>全局函数实现左移重载</span>
<span class="pl-c"><span class="pl-c">//</span>ostream对象只能有一个</span>
ostream&amp; <span class="pl-k">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) {
	out &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>a:<span class="pl-pds">"</span></span> &lt;&lt; p.<span class="pl-smi">m_A</span> &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> b:<span class="pl-pds">"</span></span> &lt;&lt; p.<span class="pl-smi">m_B</span>;
	<span class="pl-k">return</span> out;
}

<span class="pl-k">void</span> <span class="pl-en">test</span>() {

	Person <span class="pl-smi">p1</span>(<span class="pl-c1">10</span>, <span class="pl-c1">20</span>);

	cout &lt;&lt; p1 &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span> &lt;&lt; endl; <span class="pl-c"><span class="pl-c">//</span>链式编程</span>
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<h5>1.5.3 递增运算符重载</h5>
<p>作用： 通过重载递增运算符，实现自己的整型数据</p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">MyInteger</span> {

	<span class="pl-k">friend</span> ostream&amp; <span class="pl-k">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);

<span class="pl-k">public:</span>
	<span class="pl-en">MyInteger</span>() {
		m_Num = <span class="pl-c1">0</span>;
	}
	<span class="pl-c"><span class="pl-c">//</span>前置++</span>
	MyInteger&amp; <span class="pl-k">operator</span>++() {
		<span class="pl-c"><span class="pl-c">//</span>先++</span>
		m_Num++;
		<span class="pl-c"><span class="pl-c">//</span>再返回</span>
		<span class="pl-k">return</span> *<span class="pl-c1">this</span>;
	}

	<span class="pl-c"><span class="pl-c">//</span>后置++</span>
	MyInteger <span class="pl-k">operator</span>++(<span class="pl-k">int</span>) {
		<span class="pl-c"><span class="pl-c">//</span>先返回</span>
		MyInteger temp = *<span class="pl-c1">this</span>; <span class="pl-c"><span class="pl-c">//</span>记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span>
		m_Num++;
		<span class="pl-k">return</span> temp;
	}

<span class="pl-k">private:</span>
	<span class="pl-k">int</span> m_Num;
};


ostream&amp; <span class="pl-k">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) {
	out &lt;&lt; myint.<span class="pl-smi">m_Num</span>;
	<span class="pl-k">return</span> out;
}


<span class="pl-c"><span class="pl-c">//</span>前置++ 先++ 再返回</span>
<span class="pl-k">void</span> <span class="pl-en">test01</span>() {
	MyInteger myInt;
	cout &lt;&lt; ++myInt &lt;&lt; endl;
	cout &lt;&lt; myInt &lt;&lt; endl;
}

<span class="pl-c"><span class="pl-c">//</span>后置++ 先返回 再++</span>
<span class="pl-k">void</span> <span class="pl-en">test02</span>() {

	MyInteger myInt;
	cout &lt;&lt; myInt++ &lt;&lt; endl;
	cout &lt;&lt; myInt &lt;&lt; endl;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();
	<span class="pl-c"><span class="pl-c">//</span>test02();</span>

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<blockquote>
<p>总结： 前置递增返回引用，后置递增返回值</p>
</blockquote>
<h5>1.5.4 赋值运算符重载</h5>
<p>c++编译器至少给一个类添加4个函数</p>
<ol>
<li>默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>赋值运算符 operator=, 对属性进行值拷贝</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Person</span>
{
<span class="pl-k">public:</span>

	<span class="pl-en">Person</span>(<span class="pl-k">int</span> age)
	{
		<span class="pl-c"><span class="pl-c">//</span>将年龄数据开辟到堆区</span>
		m_Age = <span class="pl-k">new</span> <span class="pl-c1">int</span>(age);
	}

	<span class="pl-c"><span class="pl-c">//</span>重载赋值运算符 </span>
	Person&amp; <span class="pl-k">operator</span>=(Person &amp;p)
	{
		<span class="pl-k">if</span> (m_Age != <span class="pl-c1">NULL</span>)
		{
			<span class="pl-k">delete</span> m_Age;
			m_Age = <span class="pl-c1">NULL</span>;
		}
		<span class="pl-c"><span class="pl-c">//</span>编译器提供的代码是浅拷贝</span>
		<span class="pl-c"><span class="pl-c">//</span>m_Age = p.m_Age;</span>

		<span class="pl-c"><span class="pl-c">//</span>提供深拷贝 解决浅拷贝的问题</span>
		m_Age = <span class="pl-k">new</span> <span class="pl-c1">int</span>(*p.<span class="pl-smi">m_Age</span>);

		<span class="pl-c"><span class="pl-c">//</span>返回自身</span>
		<span class="pl-k">return</span> *<span class="pl-c1">this</span>;
	}


	<span class="pl-en">~Person</span>()
	{
		<span class="pl-k">if</span> (m_Age != <span class="pl-c1">NULL</span>)
		{
			<span class="pl-k">delete</span> m_Age;
			m_Age = <span class="pl-c1">NULL</span>;
		}
	}

	<span class="pl-c"><span class="pl-c">//</span>年龄的指针</span>
	<span class="pl-k">int</span> *m_Age;

};


<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	Person <span class="pl-smi">p1</span>(<span class="pl-c1">18</span>);

	Person <span class="pl-smi">p2</span>(<span class="pl-c1">20</span>);

	Person <span class="pl-smi">p3</span>(<span class="pl-c1">30</span>);

	p3 = p2 = p1; <span class="pl-c"><span class="pl-c">//</span>赋值操作</span>

	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>p1的年龄为：<span class="pl-pds">"</span></span> &lt;&lt; *p1.<span class="pl-smi">m_Age</span> &lt;&lt; endl;

	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>p2的年龄为：<span class="pl-pds">"</span></span> &lt;&lt; *p2.<span class="pl-smi">m_Age</span> &lt;&lt; endl;

	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>p3的年龄为：<span class="pl-pds">"</span></span> &lt;&lt; *p3.<span class="pl-smi">m_Age</span> &lt;&lt; endl;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();

	<span class="pl-c"><span class="pl-c">//</span>int a = 10;</span>
	<span class="pl-c"><span class="pl-c">//</span>int b = 20;</span>
	<span class="pl-c"><span class="pl-c">//</span>int c = 30;</span>

	<span class="pl-c"><span class="pl-c">//</span>c = b = a;</span>
	<span class="pl-c"><span class="pl-c">//</span>cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;</span>
	<span class="pl-c"><span class="pl-c">//</span>cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl;</span>
	<span class="pl-c"><span class="pl-c">//</span>cout &lt;&lt; "c = " &lt;&lt; c &lt;&lt; endl;</span>

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h5>1.5.5 关系运算符重载</h5>
<p>**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Person</span>
{
<span class="pl-k">public:</span>
	<span class="pl-en">Person</span>(string name, <span class="pl-k">int</span> age)
	{
		<span class="pl-c1">this</span>-&gt;<span class="pl-smi">m_Name</span> = name;
		<span class="pl-c1">this</span>-&gt;<span class="pl-smi">m_Age</span> = age;
	};

	<span class="pl-k">bool</span> <span class="pl-k">operator</span>==(Person &amp; p)
	{
		<span class="pl-k">if</span> (<span class="pl-c1">this</span>-&gt;<span class="pl-smi">m_Name</span> == p.<span class="pl-smi">m_Name</span> &amp;&amp; <span class="pl-c1">this</span>-&gt;<span class="pl-smi">m_Age</span> == p.<span class="pl-smi">m_Age</span>)
		{
			<span class="pl-k">return</span> <span class="pl-c1">true</span>;
		}
		<span class="pl-k">else</span>
		{
			<span class="pl-k">return</span> <span class="pl-c1">false</span>;
		}
	}

	<span class="pl-k">bool</span> <span class="pl-k">operator</span>!=(Person &amp; p)
	{
		<span class="pl-k">if</span> (<span class="pl-c1">this</span>-&gt;<span class="pl-smi">m_Name</span> == p.<span class="pl-smi">m_Name</span> &amp;&amp; <span class="pl-c1">this</span>-&gt;<span class="pl-smi">m_Age</span> == p.<span class="pl-smi">m_Age</span>)
		{
			<span class="pl-k">return</span> <span class="pl-c1">false</span>;
		}
		<span class="pl-k">else</span>
		{
			<span class="pl-k">return</span> <span class="pl-c1">true</span>;
		}
	}

	string m_Name;
	<span class="pl-k">int</span> m_Age;
};

<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	<span class="pl-c"><span class="pl-c">//</span>int a = 0;</span>
	<span class="pl-c"><span class="pl-c">//</span>int b = 0;</span>

	Person <span class="pl-smi">a</span>(<span class="pl-s"><span class="pl-pds">"</span>孙悟空<span class="pl-pds">"</span></span>, <span class="pl-c1">18</span>);
	Person <span class="pl-smi">b</span>(<span class="pl-s"><span class="pl-pds">"</span>孙悟空<span class="pl-pds">"</span></span>, <span class="pl-c1">18</span>);

	<span class="pl-k">if</span> (a == b)
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>a和b相等<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-k">else</span>
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>a和b不相等<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}

	<span class="pl-k">if</span> (a != b)
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>a和b不相等<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-k">else</span>
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>a和b相等<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
}


<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h5>1.5.6 函数调用运算符重载</h5>
<ul>
<li>函数调用运算符 () 也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">MyPrint</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">void</span> <span class="pl-en">operator</span>()(string text)
	{
		cout &lt;&lt; text &lt;&lt; endl;
	}

};
<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	<span class="pl-c"><span class="pl-c">//</span>重载的（）操作符 也称为仿函数</span>
	MyPrint myFunc;
	<span class="pl-c1">myFunc</span>(<span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>);
}


<span class="pl-k">class</span> <span class="pl-en">MyAdd</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">int</span> <span class="pl-en">operator</span>()(<span class="pl-k">int</span> v1, <span class="pl-k">int</span> v2)
	{
		<span class="pl-k">return</span> v1 + v2;
	}
};

<span class="pl-k">void</span> <span class="pl-en">test02</span>()
{
	MyAdd add;
	<span class="pl-k">int</span> ret = <span class="pl-c1">add</span>(<span class="pl-c1">10</span>, <span class="pl-c1">10</span>);
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>ret = <span class="pl-pds">"</span></span> &lt;&lt; ret &lt;&lt; endl;

	<span class="pl-c"><span class="pl-c">//</span>匿名对象调用  </span>
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>MyAdd()(100,100) = <span class="pl-pds">"</span></span> &lt;&lt; <span class="pl-c1">MyAdd</span>()(<span class="pl-c1">100</span>, <span class="pl-c1">100</span>) &lt;&lt; endl;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();
	<span class="pl-c1">test02</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h4>1.6 继承</h4>
<p><strong>继承是面向对象三大特性之一</strong></p>
<p>我们可以考虑利用继承的技术，减少重复代码</p>
<h5>1.6.1 继承的基本语法</h5>
<p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>
<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>
<p><strong>普通实现：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-c"><span class="pl-c">//</span>Java页面</span>
<span class="pl-k">class</span> <span class="pl-en">Java</span> 
{
<span class="pl-k">public:</span>
	<span class="pl-k">void</span> <span class="pl-en">header</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>首页、公开课、登录、注册...（公共头部）<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-k">void</span> <span class="pl-en">footer</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>帮助中心、交流合作、站内地图...(公共底部)<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-k">void</span> <span class="pl-en">left</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Java,Python,C++...(公共分类列表)<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-k">void</span> <span class="pl-en">content</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>JAVA学科视频<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
};
<span class="pl-c"><span class="pl-c">//</span>Python页面</span>
<span class="pl-k">class</span> <span class="pl-en">Python</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">void</span> <span class="pl-en">header</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>首页、公开课、登录、注册...（公共头部）<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-k">void</span> <span class="pl-en">footer</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>帮助中心、交流合作、站内地图...(公共底部)<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-k">void</span> <span class="pl-en">left</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Java,Python,C++...(公共分类列表)<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-k">void</span> <span class="pl-en">content</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Python学科视频<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
};
<span class="pl-c"><span class="pl-c">//</span>C++页面</span>
<span class="pl-k">class</span> <span class="pl-en">CPP</span> 
{
<span class="pl-k">public:</span>
	<span class="pl-k">void</span> <span class="pl-en">header</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>首页、公开课、登录、注册...（公共头部）<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-k">void</span> <span class="pl-en">footer</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>帮助中心、交流合作、站内地图...(公共底部)<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-k">void</span> <span class="pl-en">left</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Java,Python,C++...(公共分类列表)<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-k">void</span> <span class="pl-en">content</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>C++学科视频<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
};

<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	<span class="pl-c"><span class="pl-c">//</span>Java页面</span>
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Java下载视频页面如下： <span class="pl-pds">"</span></span> &lt;&lt; endl;
	Java ja;
	ja.<span class="pl-c1">header</span>();
	ja.<span class="pl-c1">footer</span>();
	ja.<span class="pl-c1">left</span>();
	ja.<span class="pl-c1">content</span>();
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>--------------------<span class="pl-pds">"</span></span> &lt;&lt; endl;

	<span class="pl-c"><span class="pl-c">//</span>Python页面</span>
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Python下载视频页面如下： <span class="pl-pds">"</span></span> &lt;&lt; endl;
	Python py;
	py.<span class="pl-c1">header</span>();
	py.<span class="pl-c1">footer</span>();
	py.<span class="pl-c1">left</span>();
	py.<span class="pl-c1">content</span>();
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>--------------------<span class="pl-pds">"</span></span> &lt;&lt; endl;

	<span class="pl-c"><span class="pl-c">//</span>C++页面</span>
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>C++下载视频页面如下： <span class="pl-pds">"</span></span> &lt;&lt; endl;
	CPP cp;
	cp.<span class="pl-c1">header</span>();
	cp.<span class="pl-c1">footer</span>();
	cp.<span class="pl-c1">left</span>();
	cp.<span class="pl-c1">content</span>();

}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p><strong>继承实现：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-c"><span class="pl-c">//</span>公共页面</span>
<span class="pl-k">class</span> <span class="pl-en">BasePage</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">void</span> <span class="pl-en">header</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>首页、公开课、登录、注册...（公共头部）<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}

	<span class="pl-k">void</span> <span class="pl-en">footer</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>帮助中心、交流合作、站内地图...(公共底部)<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-k">void</span> <span class="pl-en">left</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Java,Python,C++...(公共分类列表)<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}

};

<span class="pl-c"><span class="pl-c">//</span>Java页面</span>
<span class="pl-k">class</span> <span class="pl-en">Java</span> : <span class="pl-k">public</span> <span class="pl-en">BasePage</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">void</span> <span class="pl-en">content</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>JAVA学科视频<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
};
<span class="pl-c"><span class="pl-c">//</span>Python页面</span>
<span class="pl-k">class</span> <span class="pl-en">Python</span> : <span class="pl-k">public</span> <span class="pl-en">BasePage</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">void</span> <span class="pl-en">content</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Python学科视频<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
};
<span class="pl-c"><span class="pl-c">//</span>C++页面</span>
<span class="pl-k">class</span> <span class="pl-en">CPP</span> : <span class="pl-k">public</span> <span class="pl-en">BasePage</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">void</span> <span class="pl-en">content</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>C++学科视频<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
};

<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	<span class="pl-c"><span class="pl-c">//</span>Java页面</span>
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Java下载视频页面如下： <span class="pl-pds">"</span></span> &lt;&lt; endl;
	Java ja;
	ja.<span class="pl-c1">header</span>();
	ja.<span class="pl-c1">footer</span>();
	ja.<span class="pl-c1">left</span>();
	ja.<span class="pl-c1">content</span>();
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>--------------------<span class="pl-pds">"</span></span> &lt;&lt; endl;

	<span class="pl-c"><span class="pl-c">//</span>Python页面</span>
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Python下载视频页面如下： <span class="pl-pds">"</span></span> &lt;&lt; endl;
	Python py;
	py.<span class="pl-c1">header</span>();
	py.<span class="pl-c1">footer</span>();
	py.<span class="pl-c1">left</span>();
	py.<span class="pl-c1">content</span>();
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>--------------------<span class="pl-pds">"</span></span> &lt;&lt; endl;

	<span class="pl-c"><span class="pl-c">//</span>C++页面</span>
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>C++下载视频页面如下： <span class="pl-pds">"</span></span> &lt;&lt; endl;
	CPP cp;
	cp.<span class="pl-c1">header</span>();
	cp.<span class="pl-c1">footer</span>();
	cp.<span class="pl-c1">left</span>();
	cp.<span class="pl-c1">content</span>();

}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p><strong>总结：</strong></p>
<p>继承的好处：可以减少重复的代码</p>
<p>class A : public B;</p>
<p>A 类称为子类 或 派生类</p>
<p>B 类称为父类 或 基类</p>
<p><strong>派生类中的成员，包含两大部分</strong>：</p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<h5>1.6.2 继承方式</h5>
<p>继承的语法：<code class="notranslate">class 子类 : 继承方式 父类</code></p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Base1</span>
{
<span class="pl-k">public:</span> 
	<span class="pl-k">int</span> m_A;
<span class="pl-k">protected:</span>
	<span class="pl-k">int</span> m_B;
<span class="pl-k">private:</span>
	<span class="pl-k">int</span> m_C;
};

<span class="pl-c"><span class="pl-c">//</span>公共继承</span>
<span class="pl-k">class</span> <span class="pl-en">Son1</span> :<span class="pl-k">public</span> <span class="pl-en">Base1</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">void</span> <span class="pl-en">func</span>()
	{
		m_A; <span class="pl-c"><span class="pl-c">//</span>可访问 public权限</span>
		m_B; <span class="pl-c"><span class="pl-c">//</span>可访问 protected权限</span>
		<span class="pl-c"><span class="pl-c">//</span>m_C; //不可访问</span>
	}
};

<span class="pl-k">void</span> <span class="pl-en">myClass</span>()
{
	Son1 s1;
	s1.<span class="pl-smi">m_A</span>; <span class="pl-c"><span class="pl-c">//</span>其他类只能访问到公共权限</span>
}

<span class="pl-c"><span class="pl-c">//</span>保护继承</span>
<span class="pl-k">class</span> <span class="pl-en">Base2</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">int</span> m_A;
<span class="pl-k">protected:</span>
	<span class="pl-k">int</span> m_B;
<span class="pl-k">private:</span>
	<span class="pl-k">int</span> m_C;
};
<span class="pl-k">class</span> <span class="pl-en">Son2</span>:<span class="pl-k">protected</span> <span class="pl-en">Base2</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">void</span> <span class="pl-en">func</span>()
	{
		m_A; <span class="pl-c"><span class="pl-c">//</span>可访问 protected权限</span>
		m_B; <span class="pl-c"><span class="pl-c">//</span>可访问 protected权限</span>
		<span class="pl-c"><span class="pl-c">//</span>m_C; //不可访问</span>
	}
};
<span class="pl-k">void</span> <span class="pl-en">myClass2</span>()
{
	Son2 s;
	<span class="pl-c"><span class="pl-c">//</span>s.m_A; //不可访问</span>
}

<span class="pl-c"><span class="pl-c">//</span>私有继承</span>
<span class="pl-k">class</span> <span class="pl-en">Base3</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">int</span> m_A;
<span class="pl-k">protected:</span>
	<span class="pl-k">int</span> m_B;
<span class="pl-k">private:</span>
	<span class="pl-k">int</span> m_C;
};
<span class="pl-k">class</span> <span class="pl-en">Son3</span>:<span class="pl-k">private</span> <span class="pl-en">Base3</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">void</span> <span class="pl-en">func</span>()
	{
		m_A; <span class="pl-c"><span class="pl-c">//</span>可访问 private权限</span>
		m_B; <span class="pl-c"><span class="pl-c">//</span>可访问 private权限</span>
		<span class="pl-c"><span class="pl-c">//</span>m_C; //不可访问</span>
	}
};
<span class="pl-k">class</span> <span class="pl-en">GrandSon3</span> :<span class="pl-k">public</span> <span class="pl-en">Son3</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">void</span> <span class="pl-en">func</span>()
	{
		<span class="pl-c"><span class="pl-c">//</span>Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span>
		<span class="pl-c"><span class="pl-c">//</span>m_A;</span>
		<span class="pl-c"><span class="pl-c">//</span>m_B;</span>
		<span class="pl-c"><span class="pl-c">//</span>m_C;</span>
	}
};</pre></div>
<h5>1.6.3 继承中的对象模型</h5>
<p><strong>问题：</strong> 从父类继承过来的成员，哪些属于子类对象中？</p>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Base</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">int</span> m_A;
<span class="pl-k">protected:</span>
	<span class="pl-k">int</span> m_B;
<span class="pl-k">private:</span>
	<span class="pl-k">int</span> m_C; <span class="pl-c"><span class="pl-c">//</span>私有成员只是被隐藏了，但是还是会继承下去</span>
};

<span class="pl-c"><span class="pl-c">//</span>公共继承</span>
<span class="pl-k">class</span> <span class="pl-en">Son</span> :<span class="pl-k">public</span> <span class="pl-en">Base</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">int</span> m_D;
};

<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>sizeof Son = <span class="pl-pds">"</span></span> &lt;&lt; <span class="pl-k">sizeof</span>(Son) &lt;&lt; endl;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p>打开工具窗口后，定位到当前CPP文件的盘符</p>
<p>然后输入： cl /d1 reportSingleClassLayout查看的类名 所属文件名</p>
<blockquote>
<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
</blockquote>
<h5>1.6.4 继承中构造和析构顺序</h5>
<p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Base</span> 
{
<span class="pl-k">public:</span>
	<span class="pl-en">Base</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Base构造函数!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-en">~Base</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Base析构函数!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
};

<span class="pl-k">class</span> <span class="pl-en">Son</span> : <span class="pl-k">public</span> <span class="pl-en">Base</span>
{
<span class="pl-k">public:</span>
	<span class="pl-en">Son</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Son构造函数!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-en">~Son</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Son析构函数!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}

};


<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	<span class="pl-c"><span class="pl-c">//</span>继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span>
	Son s;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<blockquote>
<p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
</blockquote>
<h5>1.6.5 继承同名成员处理方式</h5>
<p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>
<ul>
<li>访问子类同名成员 直接访问即可</li>
<li>访问父类同名成员 需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Base</span> {
<span class="pl-k">public:</span>
	<span class="pl-en">Base</span>()
	{
		m_A = <span class="pl-c1">100</span>;
	}

	<span class="pl-k">void</span> <span class="pl-en">func</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Base - func()调用<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}

	<span class="pl-k">void</span> <span class="pl-en">func</span>(<span class="pl-k">int</span> a)
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Base - func(int a)调用<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}

<span class="pl-k">public:</span>
	<span class="pl-k">int</span> m_A;
};


<span class="pl-k">class</span> <span class="pl-en">Son</span> : <span class="pl-k">public</span> <span class="pl-en">Base</span> {
<span class="pl-k">public:</span>
	<span class="pl-en">Son</span>()
	{
		m_A = <span class="pl-c1">200</span>;
	}

	<span class="pl-c"><span class="pl-c">//</span>当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span>
	<span class="pl-c"><span class="pl-c">//</span>如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span>
	<span class="pl-k">void</span> <span class="pl-en">func</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Son - func()调用<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
<span class="pl-k">public:</span>
	<span class="pl-k">int</span> m_A;
};

<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	Son s;

	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Son下的m_A = <span class="pl-pds">"</span></span> &lt;&lt; s.<span class="pl-smi">m_A</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Base下的m_A = <span class="pl-pds">"</span></span> &lt;&lt; s.<span class="pl-smi">Base</span>::m_A &lt;&lt; endl;

	s.<span class="pl-c1">func</span>();
	s.<span class="pl-smi">Base</span><span class="pl-c1">::func</span>();
	s.<span class="pl-smi">Base</span><span class="pl-c1">::func</span>(<span class="pl-c1">10</span>);

}
<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();
	
	<span class="pl-k">return</span> EXIT_SUCCESS;
}</pre></div>
<p>总结：</p>
<ol>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li>
</ol>
<h5>1.6.6 继承同名静态成员处理方式</h5>
<p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员 直接访问即可</li>
<li>访问父类同名成员 需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Base</span> {
<span class="pl-k">public:</span>
	<span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">func</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Base - static void func()<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">func</span>(<span class="pl-k">int</span> a)
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Base - static void func(int a)<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}

	<span class="pl-k">static</span> <span class="pl-k">int</span> m_A;
};

<span class="pl-k">int</span> Base::m_A = <span class="pl-c1">100</span>;

<span class="pl-k">class</span> <span class="pl-en">Son</span> : <span class="pl-k">public</span> <span class="pl-en">Base</span> {
<span class="pl-k">public:</span>
	<span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">func</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Son - static void func()<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-k">static</span> <span class="pl-k">int</span> m_A;
};

<span class="pl-k">int</span> Son::m_A = <span class="pl-c1">200</span>;

<span class="pl-c"><span class="pl-c">//</span>同名成员属性</span>
<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	<span class="pl-c"><span class="pl-c">//</span>通过对象访问</span>
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>通过对象访问： <span class="pl-pds">"</span></span> &lt;&lt; endl;
	Son s;
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Son  下 m_A = <span class="pl-pds">"</span></span> &lt;&lt; s.<span class="pl-smi">m_A</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Base 下 m_A = <span class="pl-pds">"</span></span> &lt;&lt; s.<span class="pl-smi">Base</span>::m_A &lt;&lt; endl;

	<span class="pl-c"><span class="pl-c">//</span>通过类名访问</span>
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>通过类名访问： <span class="pl-pds">"</span></span> &lt;&lt; endl;
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Son  下 m_A = <span class="pl-pds">"</span></span> &lt;&lt; Son::m_A &lt;&lt; endl;
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Base 下 m_A = <span class="pl-pds">"</span></span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;
}

<span class="pl-c"><span class="pl-c">//</span>同名成员函数</span>
<span class="pl-k">void</span> <span class="pl-en">test02</span>()
{
	<span class="pl-c"><span class="pl-c">//</span>通过对象访问</span>
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>通过对象访问： <span class="pl-pds">"</span></span> &lt;&lt; endl;
	Son s;
	s.<span class="pl-c1">func</span>();
	s.<span class="pl-smi">Base</span><span class="pl-c1">::func</span>();

	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>通过类名访问： <span class="pl-pds">"</span></span> &lt;&lt; endl;
	<span class="pl-c1">Son::func</span>();
	<span class="pl-c1">Son::Base::func</span>();
	<span class="pl-c"><span class="pl-c">//</span>出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span>
	<span class="pl-c1">Son::Base::func</span>(<span class="pl-c1">100</span>);
}
<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c"><span class="pl-c">//</span>test01();</span>
	<span class="pl-c1">test02</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<blockquote>
<p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>
</blockquote>
<h5>1.6.7 多继承语法</h5>
<p>C++允许<strong>一个类继承多个类</strong></p>
<p>语法： <code class="notranslate">class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++实际开发中不建议用多继承</strong></p>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Base1</span> {
<span class="pl-k">public:</span>
	<span class="pl-en">Base1</span>()
	{
		m_A = <span class="pl-c1">100</span>;
	}
<span class="pl-k">public:</span>
	<span class="pl-k">int</span> m_A;
};

<span class="pl-k">class</span> <span class="pl-en">Base2</span> {
<span class="pl-k">public:</span>
	<span class="pl-en">Base2</span>()
	{
		m_A = <span class="pl-c1">200</span>;  <span class="pl-c"><span class="pl-c">//</span>开始是m_B 不会出问题，但是改为mA就会出现不明确</span>
	}
<span class="pl-k">public:</span>
	<span class="pl-k">int</span> m_A;
};

<span class="pl-c"><span class="pl-c">//</span>语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span>
<span class="pl-k">class</span> <span class="pl-en">Son</span> : <span class="pl-k">public</span> <span class="pl-en">Base2</span>, <span class="pl-k">public</span> <span class="pl-en">Base1</span> 
{
<span class="pl-k">public:</span>
	<span class="pl-en">Son</span>()
	{
		m_C = <span class="pl-c1">300</span>;
		m_D = <span class="pl-c1">400</span>;
	}
<span class="pl-k">public:</span>
	<span class="pl-k">int</span> m_C;
	<span class="pl-k">int</span> m_D;
};


<span class="pl-c"><span class="pl-c">//</span>多继承容易产生成员同名的情况</span>
<span class="pl-c"><span class="pl-c">//</span>通过使用类名作用域可以区分调用哪一个基类的成员</span>
<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	Son s;
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>sizeof Son = <span class="pl-pds">"</span></span> &lt;&lt; <span class="pl-k">sizeof</span>(s) &lt;&lt; endl;
	cout &lt;&lt; s.<span class="pl-smi">Base1</span>::m_A &lt;&lt; endl;
	cout &lt;&lt; s.<span class="pl-smi">Base2</span>::m_A &lt;&lt; endl;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<blockquote>
<p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
</blockquote>
<h5>1.6.8 菱形继承</h5>
<p><strong>菱形继承概念：</strong></p>
<p>两个派生类继承同一个基类</p>
<p>又有某个类同时继承者两个派生类</p>
<p>这种继承被称为菱形继承，或者钻石继承</p>
<p><strong>菱形继承问题：</strong></p>
<ol>
<li>
<pre class="notranslate"><code class="notranslate">羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。
</code></pre>
</li>
<li>
<p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Animal</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">int</span> m_Age;
};

<span class="pl-c"><span class="pl-c">//</span>继承前加virtual关键字后，变为虚继承</span>
<span class="pl-c"><span class="pl-c">//</span>此时公共的父类Animal称为虚基类</span>
<span class="pl-k">class</span> <span class="pl-en">Sheep</span> : <span class="pl-k">virtual</span> public Animal {};
<span class="pl-k">class</span> <span class="pl-en">Tuo</span>   : <span class="pl-k">virtual</span> public Animal {};
<span class="pl-k">class</span> <span class="pl-en">SheepTuo</span> : <span class="pl-k">public</span> <span class="pl-en">Sheep</span>, <span class="pl-k">public</span> <span class="pl-en">Tuo</span> {};

<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	SheepTuo st;
	st.<span class="pl-smi">Sheep</span>::m_Age = <span class="pl-c1">100</span>;
	st.<span class="pl-smi">Tuo</span>::m_Age = <span class="pl-c1">200</span>;

	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>st.Sheep::m_Age = <span class="pl-pds">"</span></span> &lt;&lt; st.<span class="pl-smi">Sheep</span>::m_Age &lt;&lt; endl;
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>st.Tuo::m_Age = <span class="pl-pds">"</span></span> &lt;&lt;  st.<span class="pl-smi">Tuo</span>::m_Age &lt;&lt; endl;
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>st.m_Age = <span class="pl-pds">"</span></span> &lt;&lt; st.<span class="pl-smi">m_Age</span> &lt;&lt; endl;
}


<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p>总结：</p>
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承问题</li>
</ul>
<h4>1.7 多态</h4>
<h5>1.7.1 多态的基本概念</h5>
<p><strong>多态是C++面向对象三大特性之一</strong></p>
<p>多态分为两类</p>
<ul>
<li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li>
</ul>
<p>下面通过案例进行讲解多态</p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Animal</span>
{
<span class="pl-k">public:</span>
	<span class="pl-c"><span class="pl-c">//</span>Speak函数就是虚函数</span>
	<span class="pl-c"><span class="pl-c">//</span>函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">speak</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>动物在说话<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
};

<span class="pl-k">class</span> <span class="pl-en">Cat</span> :<span class="pl-k">public</span> <span class="pl-en">Animal</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">void</span> <span class="pl-en">speak</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>小猫在说话<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
};

<span class="pl-k">class</span> <span class="pl-en">Dog</span> :<span class="pl-k">public</span> <span class="pl-en">Animal</span>
{
<span class="pl-k">public:</span>

	<span class="pl-k">void</span> <span class="pl-en">speak</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>小狗在说话<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}

};
<span class="pl-c"><span class="pl-c">//</span>我们希望传入什么对象，那么就调用什么对象的函数</span>
<span class="pl-c"><span class="pl-c">//</span>如果函数地址在编译阶段就能确定，那么静态联编</span>
<span class="pl-c"><span class="pl-c">//</span>如果函数地址在运行阶段才能确定，就是动态联编</span>

<span class="pl-k">void</span> <span class="pl-en">DoSpeak</span>(Animal &amp; animal)
{
	animal.<span class="pl-c1">speak</span>();
}
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"><span class="pl-c">//</span>多态满足条件： </span>
<span class="pl-c"><span class="pl-c">//</span>1、有继承关系</span>
<span class="pl-c"><span class="pl-c">//</span>2、子类重写父类中的虚函数</span>
<span class="pl-c"><span class="pl-c">//</span>多态使用：</span>
<span class="pl-c"><span class="pl-c">//</span>父类指针或引用指向子类对象</span>

<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	Cat cat;
	<span class="pl-c1">DoSpeak</span>(cat);


	Dog dog;
	<span class="pl-c1">DoSpeak</span>(dog);
}


<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p>总结：</p>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p>
<h5>1.7.2 多态案例一-计算器类</h5>
<p>案例描述：</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点：</p>
<ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-c"><span class="pl-c">//</span>普通实现</span>
<span class="pl-k">class</span> <span class="pl-en">Calculator</span> {
<span class="pl-k">public:</span>
	<span class="pl-k">int</span> <span class="pl-en">getResult</span>(string oper)
	{
		<span class="pl-k">if</span> (oper == <span class="pl-s"><span class="pl-pds">"</span>+<span class="pl-pds">"</span></span>) {
			<span class="pl-k">return</span> m_Num1 + m_Num2;
		}
		<span class="pl-k">else</span> <span class="pl-k">if</span> (oper == <span class="pl-s"><span class="pl-pds">"</span>-<span class="pl-pds">"</span></span>) {
			<span class="pl-k">return</span> m_Num1 - m_Num2;
		}
		<span class="pl-k">else</span> <span class="pl-k">if</span> (oper == <span class="pl-s"><span class="pl-pds">"</span>*<span class="pl-pds">"</span></span>) {
			<span class="pl-k">return</span> m_Num1 * m_Num2;
		}
		<span class="pl-c"><span class="pl-c">//</span>如果要提供新的运算，需要修改源码</span>
	}
<span class="pl-k">public:</span>
	<span class="pl-k">int</span> m_Num1;
	<span class="pl-k">int</span> m_Num2;
};

<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	<span class="pl-c"><span class="pl-c">//</span>普通实现测试</span>
	Calculator c;
	c.<span class="pl-smi">m_Num1</span> = <span class="pl-c1">10</span>;
	c.<span class="pl-smi">m_Num2</span> = <span class="pl-c1">10</span>;
	cout &lt;&lt; c.<span class="pl-smi">m_Num1</span> &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> + <span class="pl-pds">"</span></span> &lt;&lt; c.<span class="pl-smi">m_Num2</span> &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> = <span class="pl-pds">"</span></span> &lt;&lt; c.<span class="pl-c1">getResult</span>(<span class="pl-s"><span class="pl-pds">"</span>+<span class="pl-pds">"</span></span>) &lt;&lt; endl;

	cout &lt;&lt; c.<span class="pl-smi">m_Num1</span> &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> - <span class="pl-pds">"</span></span> &lt;&lt; c.<span class="pl-smi">m_Num2</span> &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> = <span class="pl-pds">"</span></span> &lt;&lt; c.<span class="pl-c1">getResult</span>(<span class="pl-s"><span class="pl-pds">"</span>-<span class="pl-pds">"</span></span>) &lt;&lt; endl;

	cout &lt;&lt; c.<span class="pl-smi">m_Num1</span> &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> * <span class="pl-pds">"</span></span> &lt;&lt; c.<span class="pl-smi">m_Num2</span> &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> = <span class="pl-pds">"</span></span> &lt;&lt; c.<span class="pl-c1">getResult</span>(<span class="pl-s"><span class="pl-pds">"</span>*<span class="pl-pds">"</span></span>) &lt;&lt; endl;
}


<span class="pl-c"><span class="pl-c">//</span>多态实现</span>
<span class="pl-c"><span class="pl-c">//</span>抽象计算器类</span>
<span class="pl-c"><span class="pl-c">//</span>多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span>
<span class="pl-k">class</span> <span class="pl-en">AbstractCalculator</span>
{
public :

	<span class="pl-k">virtual</span> <span class="pl-k">int</span> <span class="pl-en">getResult</span>()
	{
		<span class="pl-k">return</span> <span class="pl-c1">0</span>;
	}

	<span class="pl-k">int</span> m_Num1;
	<span class="pl-k">int</span> m_Num2;
};

<span class="pl-c"><span class="pl-c">//</span>加法计算器</span>
<span class="pl-k">class</span> <span class="pl-en">AddCalculator</span> :<span class="pl-k">public</span> <span class="pl-en">AbstractCalculator</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">int</span> <span class="pl-en">getResult</span>()
	{
		<span class="pl-k">return</span> m_Num1 + m_Num2;
	}
};

<span class="pl-c"><span class="pl-c">//</span>减法计算器</span>
<span class="pl-k">class</span> <span class="pl-en">SubCalculator</span> :<span class="pl-k">public</span> <span class="pl-en">AbstractCalculator</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">int</span> <span class="pl-en">getResult</span>()
	{
		<span class="pl-k">return</span> m_Num1 - m_Num2;
	}
};

<span class="pl-c"><span class="pl-c">//</span>乘法计算器</span>
<span class="pl-k">class</span> <span class="pl-en">MulCalculator</span> :<span class="pl-k">public</span> <span class="pl-en">AbstractCalculator</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">int</span> <span class="pl-en">getResult</span>()
	{
		<span class="pl-k">return</span> m_Num1 * m_Num2;
	}
};


<span class="pl-k">void</span> <span class="pl-en">test02</span>()
{
	<span class="pl-c"><span class="pl-c">//</span>创建加法计算器</span>
	AbstractCalculator *abc = <span class="pl-k">new</span> AddCalculator;
	abc-&gt;<span class="pl-smi">m_Num1</span> = <span class="pl-c1">10</span>;
	abc-&gt;<span class="pl-smi">m_Num2</span> = <span class="pl-c1">10</span>;
	cout &lt;&lt; abc-&gt;<span class="pl-smi">m_Num1</span> &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> + <span class="pl-pds">"</span></span> &lt;&lt; abc-&gt;<span class="pl-smi">m_Num2</span> &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> = <span class="pl-pds">"</span></span> &lt;&lt; abc-&gt;<span class="pl-c1">getResult</span>() &lt;&lt; endl;
	<span class="pl-k">delete</span> abc;  <span class="pl-c"><span class="pl-c">//</span>用完了记得销毁</span>

	<span class="pl-c"><span class="pl-c">//</span>创建减法计算器</span>
	abc = <span class="pl-k">new</span> SubCalculator;
	abc-&gt;<span class="pl-smi">m_Num1</span> = <span class="pl-c1">10</span>;
	abc-&gt;<span class="pl-smi">m_Num2</span> = <span class="pl-c1">10</span>;
	cout &lt;&lt; abc-&gt;<span class="pl-smi">m_Num1</span> &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> - <span class="pl-pds">"</span></span> &lt;&lt; abc-&gt;<span class="pl-smi">m_Num2</span> &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> = <span class="pl-pds">"</span></span> &lt;&lt; abc-&gt;<span class="pl-c1">getResult</span>() &lt;&lt; endl;
	<span class="pl-k">delete</span> abc;  

	<span class="pl-c"><span class="pl-c">//</span>创建乘法计算器</span>
	abc = <span class="pl-k">new</span> MulCalculator;
	abc-&gt;<span class="pl-smi">m_Num1</span> = <span class="pl-c1">10</span>;
	abc-&gt;<span class="pl-smi">m_Num2</span> = <span class="pl-c1">10</span>;
	cout &lt;&lt; abc-&gt;<span class="pl-smi">m_Num1</span> &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> * <span class="pl-pds">"</span></span> &lt;&lt; abc-&gt;<span class="pl-smi">m_Num2</span> &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> = <span class="pl-pds">"</span></span> &lt;&lt; abc-&gt;<span class="pl-c1">getResult</span>() &lt;&lt; endl;
	<span class="pl-k">delete</span> abc;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c"><span class="pl-c">//</span>test01();</span>

	<span class="pl-c1">test02</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<blockquote>
<p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p>
</blockquote>
<h5>1.7.3 纯虚函数和抽象类</h5>
<p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为<strong>纯虚函数</strong></p>
<p>纯虚函数语法：<code class="notranslate">virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p>
<p>当类中有了纯虚函数，这个类也称为抽象类</p>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Base</span>
{
<span class="pl-k">public:</span>
	<span class="pl-c"><span class="pl-c">//</span>纯虚函数</span>
	<span class="pl-c"><span class="pl-c">//</span>类中只要有一个纯虚函数就称为抽象类</span>
	<span class="pl-c"><span class="pl-c">//</span>抽象类无法实例化对象</span>
	<span class="pl-c"><span class="pl-c">//</span>子类必须重写父类中的纯虚函数，否则也属于抽象类</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">func</span>() = 0;
};

<span class="pl-k">class</span> <span class="pl-en">Son</span> :<span class="pl-k">public</span> <span class="pl-en">Base</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">func</span>() 
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>func调用<span class="pl-pds">"</span></span> &lt;&lt; endl;
	};
};

<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	Base * base = <span class="pl-c1">NULL</span>;
	<span class="pl-c"><span class="pl-c">//</span>base = new Base; // 错误，抽象类无法实例化对象</span>
	base = <span class="pl-k">new</span> Son;
	base-&gt;<span class="pl-c1">func</span>();
	<span class="pl-k">delete</span> base;<span class="pl-c"><span class="pl-c">//</span>记得销毁</span>
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h5>1.7.4 多态案例二-制作饮品</h5>
<p><strong>案例描述：</strong></p>
<p>制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料</p>
<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-c"><span class="pl-c">//</span>抽象制作饮品</span>
<span class="pl-k">class</span> <span class="pl-en">AbstractDrinking</span> {
<span class="pl-k">public:</span>
	<span class="pl-c"><span class="pl-c">//</span>烧水</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">Boil</span>() = 0;
	<span class="pl-c"><span class="pl-c">//</span>冲泡</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">Brew</span>() = 0;
	<span class="pl-c"><span class="pl-c">//</span>倒入杯中</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">PourInCup</span>() = 0;
	<span class="pl-c"><span class="pl-c">//</span>加入辅料</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">PutSomething</span>() = 0;
	<span class="pl-c"><span class="pl-c">//</span>规定流程</span>
	<span class="pl-k">void</span> <span class="pl-en">MakeDrink</span>() {
		<span class="pl-c1">Boil</span>();
		<span class="pl-c1">Brew</span>();
		<span class="pl-c1">PourInCup</span>();
		<span class="pl-c1">PutSomething</span>();
	}
};

<span class="pl-c"><span class="pl-c">//</span>制作咖啡</span>
<span class="pl-k">class</span> <span class="pl-en">Coffee</span> : <span class="pl-k">public</span> <span class="pl-en">AbstractDrinking</span> {
<span class="pl-k">public:</span>
	<span class="pl-c"><span class="pl-c">//</span>烧水</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">Boil</span>() {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>煮农夫山泉!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-c"><span class="pl-c">//</span>冲泡</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">Brew</span>() {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>冲泡咖啡!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-c"><span class="pl-c">//</span>倒入杯中</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">PourInCup</span>() {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>将咖啡倒入杯中!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-c"><span class="pl-c">//</span>加入辅料</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">PutSomething</span>() {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>加入牛奶!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
};

<span class="pl-c"><span class="pl-c">//</span>制作茶水</span>
<span class="pl-k">class</span> <span class="pl-en">Tea</span> : <span class="pl-k">public</span> <span class="pl-en">AbstractDrinking</span> {
<span class="pl-k">public:</span>
	<span class="pl-c"><span class="pl-c">//</span>烧水</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">Boil</span>() {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>煮自来水!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-c"><span class="pl-c">//</span>冲泡</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">Brew</span>() {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>冲泡茶叶!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-c"><span class="pl-c">//</span>倒入杯中</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">PourInCup</span>() {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>将茶水倒入杯中!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-c"><span class="pl-c">//</span>加入辅料</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">PutSomething</span>() {
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>加入枸杞!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
};

<span class="pl-c"><span class="pl-c">//</span>业务函数</span>
<span class="pl-k">void</span> <span class="pl-en">DoWork</span>(AbstractDrinking* drink) {
	drink-&gt;<span class="pl-c1">MakeDrink</span>();
	<span class="pl-k">delete</span> drink;
}

<span class="pl-k">void</span> <span class="pl-en">test01</span>() {
	<span class="pl-c1">DoWork</span>(<span class="pl-k">new</span> Coffee);
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>--------------<span class="pl-pds">"</span></span> &lt;&lt; endl;
	<span class="pl-c1">DoWork</span>(<span class="pl-k">new</span> Tea);
}


<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h5>1.7.5 虚析构和纯虚析构</h5>
<p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：<code class="notranslate">virtual ~类名(){}</code></p>
<p>纯虚析构语法：</p>
<p><code class="notranslate">virtual ~类名() = 0;</code></p>
<p><code class="notranslate">类名::~类名(){}</code></p>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Animal</span> {
<span class="pl-k">public:</span>

	<span class="pl-en">Animal</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Animal 构造函数调用！<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">Speak</span>() = 0;

	<span class="pl-c"><span class="pl-c">//</span>析构函数加上virtual关键字，变成虚析构函数</span>
	<span class="pl-c"><span class="pl-c">//</span>virtual ~Animal()</span>
	<span class="pl-c"><span class="pl-c">//</span>{</span>
	<span class="pl-c"><span class="pl-c">//</span>	cout &lt;&lt; "Animal虚析构函数调用！" &lt;&lt; endl;</span>
	<span class="pl-c"><span class="pl-c">//</span>}</span>


	<span class="pl-k">virtual</span> <span class="pl-en">~Animal</span>() = <span class="pl-c1">0</span>;
};

<span class="pl-en">Animal::~Animal</span>()
{
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Animal 纯虚析构函数调用！<span class="pl-pds">"</span></span> &lt;&lt; endl;
}

<span class="pl-c"><span class="pl-c">//</span>和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span>

<span class="pl-k">class</span> <span class="pl-en">Cat</span> : <span class="pl-k">public</span> <span class="pl-en">Animal</span> {
<span class="pl-k">public:</span>
	<span class="pl-en">Cat</span>(string name)
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Cat构造函数调用！<span class="pl-pds">"</span></span> &lt;&lt; endl;
		m_Name = <span class="pl-k">new</span> <span class="pl-c1">string</span>(name);
	}
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">Speak</span>()
	{
		cout &lt;&lt; *m_Name &lt;&lt;  <span class="pl-s"><span class="pl-pds">"</span>小猫在说话!<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
	<span class="pl-en">~Cat</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Cat析构函数调用!<span class="pl-pds">"</span></span> &lt;&lt; endl;
		<span class="pl-k">if</span> (<span class="pl-c1">this</span>-&gt;<span class="pl-smi">m_Name</span> != <span class="pl-c1">NULL</span>) {
			<span class="pl-k">delete</span> m_Name;
			m_Name = <span class="pl-c1">NULL</span>;
		}
	}

<span class="pl-k">public:</span>
	string *m_Name;
};

<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	Animal *animal = <span class="pl-k">new</span> <span class="pl-c1">Cat</span>(<span class="pl-s"><span class="pl-pds">"</span>Tom<span class="pl-pds">"</span></span>);
	animal-&gt;<span class="pl-c1">Speak</span>();

	<span class="pl-c"><span class="pl-c">//</span>通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span>
	<span class="pl-c"><span class="pl-c">//</span>怎么解决？给基类增加一个虚析构函数</span>
	<span class="pl-c"><span class="pl-c">//</span>虚析构函数就是用来解决通过父类指针释放子类对象</span>
	<span class="pl-k">delete</span> animal;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

	<span class="pl-c1">test01</span>();

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p>总结：</p>
<ol>
<li>
<p>虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>
</li>
<li>
<p>如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>
</li>
<li>
<p>拥有纯虚析构函数的类也属于抽象类</p>
</li>
</ol>
<h5>1.7.6 多态案例三-电脑组装</h5>
<p><strong>案例描述：</strong></p>
<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>
<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p>
<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>
<p>测试时组装三台不同的电脑进行工作</p>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>

<span class="pl-c"><span class="pl-c">//</span>抽象CPU类</span>
<span class="pl-k">class</span> <span class="pl-en">CPU</span>
{
<span class="pl-k">public:</span>
	<span class="pl-c"><span class="pl-c">//</span>抽象的计算函数</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">calculate</span>() = 0;
};

<span class="pl-c"><span class="pl-c">//</span>抽象显卡类</span>
<span class="pl-k">class</span> <span class="pl-en">VideoCard</span>
{
<span class="pl-k">public:</span>
	<span class="pl-c"><span class="pl-c">//</span>抽象的显示函数</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">display</span>() = 0;
};

<span class="pl-c"><span class="pl-c">//</span>抽象内存条类</span>
<span class="pl-k">class</span> <span class="pl-en">Memory</span>
{
<span class="pl-k">public:</span>
	<span class="pl-c"><span class="pl-c">//</span>抽象的存储函数</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">storage</span>() = 0;
};

<span class="pl-c"><span class="pl-c">//</span>电脑类</span>
<span class="pl-k">class</span> <span class="pl-en">Computer</span>
{
<span class="pl-k">public:</span>
	<span class="pl-en">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)
	{
		m_cpu = cpu;
		m_vc = vc;
		m_mem = mem;
	}

	<span class="pl-c"><span class="pl-c">//</span>提供工作的函数</span>
	<span class="pl-k">void</span> <span class="pl-en">work</span>()
	{
		<span class="pl-c"><span class="pl-c">//</span>让零件工作起来，调用接口</span>
		m_cpu-&gt;<span class="pl-c1">calculate</span>();

		m_vc-&gt;<span class="pl-c1">display</span>();

		m_mem-&gt;<span class="pl-c1">storage</span>();
	}

	<span class="pl-c"><span class="pl-c">//</span>提供析构函数 释放3个电脑零件</span>
	<span class="pl-en">~Computer</span>()
	{

		<span class="pl-c"><span class="pl-c">//</span>释放CPU零件</span>
		<span class="pl-k">if</span> (m_cpu != <span class="pl-c1">NULL</span>)
		{
			<span class="pl-k">delete</span> m_cpu;
			m_cpu = <span class="pl-c1">NULL</span>;
		}

		<span class="pl-c"><span class="pl-c">//</span>释放显卡零件</span>
		<span class="pl-k">if</span> (m_vc != <span class="pl-c1">NULL</span>)
		{
			<span class="pl-k">delete</span> m_vc;
			m_vc = <span class="pl-c1">NULL</span>;
		}

		<span class="pl-c"><span class="pl-c">//</span>释放内存条零件</span>
		<span class="pl-k">if</span> (m_mem != <span class="pl-c1">NULL</span>)
		{
			<span class="pl-k">delete</span> m_mem;
			m_mem = <span class="pl-c1">NULL</span>;
		}
	}

<span class="pl-k">private:</span>

	CPU * m_cpu; <span class="pl-c"><span class="pl-c">//</span>CPU的零件指针</span>
	VideoCard * m_vc; <span class="pl-c"><span class="pl-c">//</span>显卡零件指针</span>
	Memory * m_mem; <span class="pl-c"><span class="pl-c">//</span>内存条零件指针</span>
};

<span class="pl-c"><span class="pl-c">//</span>具体厂商</span>
<span class="pl-c"><span class="pl-c">//</span>Intel厂商</span>
<span class="pl-k">class</span> <span class="pl-en">IntelCPU</span> :<span class="pl-k">public</span> <span class="pl-en">CPU</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">calculate</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Intel的CPU开始计算了！<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
};

<span class="pl-k">class</span> <span class="pl-en">IntelVideoCard</span> :<span class="pl-k">public</span> <span class="pl-en">VideoCard</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">display</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Intel的显卡开始显示了！<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
};

<span class="pl-k">class</span> <span class="pl-en">IntelMemory</span> :<span class="pl-k">public</span> <span class="pl-en">Memory</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">storage</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Intel的内存条开始存储了！<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
};

<span class="pl-c"><span class="pl-c">//</span>Lenovo厂商</span>
<span class="pl-k">class</span> <span class="pl-en">LenovoCPU</span> :<span class="pl-k">public</span> <span class="pl-en">CPU</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">calculate</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Lenovo的CPU开始计算了！<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
};

<span class="pl-k">class</span> <span class="pl-en">LenovoVideoCard</span> :<span class="pl-k">public</span> <span class="pl-en">VideoCard</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">display</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Lenovo的显卡开始显示了！<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
};

<span class="pl-k">class</span> <span class="pl-en">LenovoMemory</span> :<span class="pl-k">public</span> <span class="pl-en">Memory</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">storage</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Lenovo的内存条开始存储了！<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
};


<span class="pl-k">void</span> <span class="pl-en">test01</span>()
{
	<span class="pl-c"><span class="pl-c">//</span>第一台电脑零件</span>
	CPU * intelCpu = <span class="pl-k">new</span> IntelCPU;
	VideoCard * intelCard = <span class="pl-k">new</span> IntelVideoCard;
	Memory * intelMem = <span class="pl-k">new</span> IntelMemory;

	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>第一台电脑开始工作：<span class="pl-pds">"</span></span> &lt;&lt; endl;
	<span class="pl-c"><span class="pl-c">//</span>创建第一台电脑</span>
	Computer * computer1 = <span class="pl-k">new</span> <span class="pl-c1">Computer</span>(intelCpu, intelCard, intelMem);
	computer1-&gt;<span class="pl-c1">work</span>();
	<span class="pl-k">delete</span> computer1;

	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>-----------------------<span class="pl-pds">"</span></span> &lt;&lt; endl;
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>第二台电脑开始工作：<span class="pl-pds">"</span></span> &lt;&lt; endl;
	<span class="pl-c"><span class="pl-c">//</span>第二台电脑组装</span>
	Computer * computer2 = <span class="pl-k">new</span> <span class="pl-c1">Computer</span>(<span class="pl-k">new</span> LenovoCPU, <span class="pl-k">new</span> LenovoVideoCard, <span class="pl-k">new</span> LenovoMemory);;
	computer2-&gt;<span class="pl-c1">work</span>();
	<span class="pl-k">delete</span> computer2;

	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>-----------------------<span class="pl-pds">"</span></span> &lt;&lt; endl;
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>第三台电脑开始工作：<span class="pl-pds">"</span></span> &lt;&lt; endl;
	<span class="pl-c"><span class="pl-c">//</span>第三台电脑组装</span>
	Computer * computer3 = <span class="pl-k">new</span> <span class="pl-c1">Computer</span>(<span class="pl-k">new</span> LenovoCPU, <span class="pl-k">new</span> IntelVideoCard, <span class="pl-k">new</span> LenovoMemory);;
	computer3-&gt;<span class="pl-c1">work</span>();
	<span class="pl-k">delete</span> computer3;

}</pre></div></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://nickyoung0514.github.io/yblog.github.io">任平生-博客</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","nickyoung0514/yblog.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}
</script>


</html>
