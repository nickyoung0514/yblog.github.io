<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>任平生-博客</title><link>https://nickyoung0514.github.io/yblog.github.io</link><description>我是任平生，分享code算法，人生感悟，编程小妙招的科技类博主</description><copyright>任平生-博客</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/38165902?v=4</url><title>avatar</title><link>https://nickyoung0514.github.io/yblog.github.io</link></image><lastBuildDate>Thu, 20 Jun 2024 11:44:31 +0000</lastBuildDate><managingEditor>任平生-博客</managingEditor><ttl>60</ttl><webMaster>任平生-博客</webMaster><item><title>十大经典排序算法(各种优化)</title><link>https://nickyoung0514.github.io/yblog.github.io/post/shi-da-jing-dian-pai-xu-suan-fa-%28-ge-zhong-you-hua-%29.html</link><description>[toc]&#13;
&#13;
- c语言描述&#13;
- 环境任意&#13;
- 算法和核心思想&#13;
- 代码实现&#13;
&#13;
**分类**&#13;
&#13;
* 交换类&#13;
  * 冒泡排序&#13;
  * 快速排序&#13;
* 分配类&#13;
  * 计数排序&#13;
  * 基数排序&#13;
* 选择类&#13;
  * 选择排序&#13;
  * 堆排序&#13;
* 归并类&#13;
  * 归并排序&#13;
* 插入类&#13;
  * 插入排序&#13;
  * 希尔排序&#13;
&#13;
&#13;
&#13;
## 冒泡排序&#13;
&#13;
- 一个基于交换的排序。</description><guid isPermaLink="true">https://nickyoung0514.github.io/yblog.github.io/post/shi-da-jing-dian-pai-xu-suan-fa-%28-ge-zhong-you-hua-%29.html</guid><pubDate>Thu, 20 Jun 2024 11:34:01 +0000</pubDate></item><item><title>【C++核心】一文理解C++面向对象（详细）</title><link>https://nickyoung0514.github.io/yblog.github.io/post/%E3%80%90C%2B%2B-he-xin-%E3%80%91-yi-wen-li-jie-C%2B%2B-mian-xiang-dui-xiang-%EF%BC%88-xiang-xi-%EF%BC%89.html</link><description> &#13;
&#13;
#### 文章目录&#13;
&#13;
*   *   [一. 类和对象](#__2)&#13;
    *   *   [1.1 封装](#11__16)&#13;
        *   *   [1.1.1 封装的意义](#111___17)&#13;
            *   [1.1.2 struct和class区别](#112_structclass_163)&#13;
            *   [1.1.3 成员属性设置为私有](#113__193)&#13;
        *   [1.2 对象的初始化和清理](#12__260)&#13;
        *   *   [1.2.1 构造函数和析构函数](#121__264)&#13;
            *   [1.2.2 构造函数的分类及调用](#122__321)&#13;
            *   [1.2.3 拷贝构造函数调用时机](#123__404)&#13;
            *   [1.2.4 构造函数调用规则](#124__481)&#13;
            *   [1.2.5 深拷贝与浅拷贝](#125__556)&#13;
            *   [1.2.6 初始化列表](#126__624)&#13;
            *   [1.2.7 类对象作为类成员](#127__666)&#13;
            *   [1.2.8 静态成员](#128__744)&#13;
        *   [1.3 C++对象模型和this指针](#13_Cthis_869)&#13;
        *   *   [1.3.1 成员变量和成员函数分开存储](#131__870)&#13;
            *   [1.3.2 this指针概念](#132_this_902)&#13;
            *   [1.3.3 空指针访问成员函数](#133__959)&#13;
            *   [1.3.4 const修饰成员函数](#134_const_1003)&#13;
        *   [1.4 友元](#14__1070)&#13;
        *   *   [1.4.1 全局函数做友元](#141__1089)&#13;
            *   [1.4.2 类做友元](#142__1137)&#13;
            *   [1.4.3 成员函数做友元](#143__1200)&#13;
        *   [1.5 运算符重载](#15__1268)&#13;
        *   *   [1.5.1 加号运算符重载](#151__1271)&#13;
            *   [1.5.2 左移运算符重载](#152__1341)&#13;
            *   [1.5.3 递增运算符重载](#153__1390)&#13;
            *   [1.5.4 赋值运算符重载](#154__1456)&#13;
            *   [1.5.5 关系运算符重载](#155__1549)&#13;
            *   [1.5.6 函数调用运算符重载](#156__1628)&#13;
        *   [1.6 继承](#16___1681)&#13;
        *   *   [1.6.1 继承的基本语法](#161__1686)&#13;
            *   [1.6.2 继承方式](#162__1904)&#13;
            *   [1.6.3 继承中的对象模型](#163__2004)&#13;
            *   [1.6.4 继承中构造和析构顺序](#164__2046)&#13;
            *   [1.6.5 继承同名成员处理方式](#165__2097)&#13;
            *   [1.6.6 继承同名静态成员处理方式](#166__2170)&#13;
            *   [1.6.7 多继承语法](#167__2250)&#13;
            *   [1.6.8 菱形继承](#168__2317)&#13;
        *   [1.7 多态](#17___2372)&#13;
        *   *   [1.7.1 多态的基本概念](#171__2373)&#13;
            *   [1.7.2 多态案例一-计算器类](#172__2467)&#13;
            *   [1.7.3 纯虚函数和抽象类](#173__2602)&#13;
            *   [1.7.4 多态案例二-制作饮品](#174__2657)&#13;
            *   [1.7.5 虚析构和纯虚析构](#175__2754)&#13;
            *   [1.7.6 多态案例三-电脑组装](#176__2866)&#13;
&#13;
### 一. 类和对象&#13;
&#13;
C++[面向对象](https://so.csdn.net/so/search?q=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1&amp;spm=1001.2101.3001.7020)的三大特性为：封装、继承、多态&#13;
&#13;
C++认为万事万物都皆为对象，对象上有其属性和行为&#13;
&#13;
**例如：**&#13;
&#13;
 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…&#13;
&#13;
 车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…&#13;
&#13;
 具有相同性质的对象，我们可以抽象称为类，人属于人类，车属于车类&#13;
&#13;
#### 1.1 封装&#13;
&#13;
##### 1.1.1 封装的意义&#13;
&#13;
封装是C++面向对象三大特性之一，封装的意义：&#13;
&#13;
*   将属性和行为作为一个整体，表现生活中的事物&#13;
*   将属性和行为加以权限控制&#13;
&#13;
**封装意义一：**&#13;
&#13;
 在设计类的时候，属性和行为写在一起，表现事物&#13;
&#13;
**语法：** `class 类名{ 访问权限： 属性 / 行为 };`&#13;
&#13;
**示例1：** 设计一个圆类，求[圆的周长](https://so.csdn.net/so/search?q=%E5%9C%86%E7%9A%84%E5%91%A8%E9%95%BF&amp;spm=1001.2101.3001.7020)&#13;
&#13;
**示例代码：**&#13;
&#13;
```cpp&#13;
//圆周率&#13;
const double PI = 3.14;&#13;
&#13;
//1、封装的意义&#13;
//将属性和行为作为一个整体，用来表现生活中的事物&#13;
&#13;
//封装一个圆类，求圆的周长&#13;
//class代表设计一个类，后面跟着的是类名&#13;
class Circle&#13;
{&#13;
public:  //访问权限  公共的权限&#13;
&#13;
	//属性&#13;
	int m_r;//半径&#13;
&#13;
	//行为&#13;
	//获取到圆的周长&#13;
	double calculateZC()&#13;
	{&#13;
		//2 * pi  * r&#13;
		//获取圆的周长&#13;
		return  2 * PI * m_r;&#13;
	}&#13;
};&#13;
&#13;
int main() {&#13;
&#13;
	//通过圆类，创建圆的对象&#13;
	// c1就是一个具体的圆&#13;
	Circle c1;&#13;
	c1.m_r = 10; //给圆对象的半径 进行赋值操作&#13;
&#13;
	//2 * pi * 10 = = 62.8&#13;
	cout &lt;&lt; '圆的周长为： ' &lt;&lt; c1.calculateZC() &lt;&lt; endl;&#13;
	&#13;
	return 0;&#13;
}&#13;
```&#13;
&#13;
**示例2：** 设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号&#13;
&#13;
**示例2代码：**&#13;
&#13;
```cpp&#13;
//学生类&#13;
class Student {&#13;
public:&#13;
	void setName(string name) {&#13;
		m_name = name;&#13;
	}&#13;
	void setID(int id) {&#13;
		m_id = id;&#13;
	}&#13;
&#13;
	void showStudent() {&#13;
		cout &lt;&lt; 'name:' &lt;&lt; m_name &lt;&lt; ' ID:' &lt;&lt; m_id &lt;&lt; endl;&#13;
	}&#13;
public:&#13;
	string m_name;&#13;
	int m_id;&#13;
};&#13;
&#13;
int main() {&#13;
&#13;
	Student stu;&#13;
	stu.setName('德玛西亚');&#13;
	stu.setID(250);&#13;
	stu.showStudent();&#13;
&#13;
	return 0;&#13;
}&#13;
&#13;
```&#13;
&#13;
**封装意义二：**&#13;
&#13;
类在设计时，可以把属性和行为放在不同的权限下，加以控制，[访问权限](https://so.csdn.net/so/search?q=%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90&amp;spm=1001.2101.3001.7020)有三种：&#13;
&#13;
1.  public 公共权限&#13;
2.  protected 保护权限&#13;
3.  private 私有权限&#13;
&#13;
**示例：**&#13;
&#13;
```cpp&#13;
//三种权限&#13;
//公共权限  public     类内可以访问  类外可以访问&#13;
//保护权限  protected  类内可以访问  类外不可以访问&#13;
//私有权限  private    类内可以访问  类外不可以访问&#13;
&#13;
class Person&#13;
{&#13;
	//姓名  公共权限&#13;
public:&#13;
	string m_Name;&#13;
&#13;
	//汽车  保护权限&#13;
protected:&#13;
	string m_Car;&#13;
&#13;
	//银行卡密码  私有权限&#13;
private:&#13;
	int m_Password;&#13;
&#13;
public:&#13;
	void func()&#13;
	{&#13;
		m_Name = '张三';&#13;
		m_Car = '拖拉机';&#13;
		m_Password = 123456;&#13;
	}&#13;
};&#13;
&#13;
int main() {&#13;
&#13;
	Person p;&#13;
	p.m_Name = '李四';&#13;
	//p.m_Car = '奔驰';  //保护权限类外访问不到&#13;
	//p.m_Password = 123; //私有权限类外访问不到&#13;
&#13;
	return 0;&#13;
}&#13;
```&#13;
&#13;
##### 1.1.2 struct和class区别&#13;
&#13;
在C++中 struct和class唯一的**区别**就在于 **默认的访问权限不同**，区别：&#13;
&#13;
*   struct 默认权限为公共&#13;
*   class 默认权限为私有&#13;
&#13;
```cpp&#13;
class C1&#13;
{&#13;
	int  m_A; //默认是私有权限&#13;
};&#13;
&#13;
struct C2&#13;
{&#13;
	int m_A;  //默认是公共权限&#13;
};&#13;
&#13;
int main() {&#13;
&#13;
	C1 c1;&#13;
	c1.m_A = 10; //错误，访问权限是私有&#13;
&#13;
	C2 c2;&#13;
	c2.m_A = 10; //正确，访问权限是公共&#13;
&#13;
	system('pause');&#13;
&#13;
	return 0;&#13;
}&#13;
```&#13;
&#13;
##### 1.1.3 成员属性设置为私有&#13;
&#13;
**优点1：** 将所有成员属性设置为私有，可以自己控制读写权限&#13;
&#13;
**优点2：** 对于写权限，我们可以检测数据的有效性&#13;
&#13;
**示例：**&#13;
&#13;
```cpp&#13;
class Person {&#13;
public:&#13;
&#13;
	//姓名设置可读可写&#13;
	void setName(string name) {&#13;
		m_Name = name;&#13;
	}&#13;
	string getName()&#13;
	{&#13;
		return m_Name;&#13;
	}&#13;
&#13;
	//获取年龄 &#13;
	int getAge() {&#13;
		return m_Age;&#13;
	}&#13;
	//设置年龄&#13;
	void setAge(int age) {&#13;
		if (age &lt; 0 || age &gt; 150) {&#13;
			cout &lt;&lt; '你个老妖精!' &lt;&lt; endl;&#13;
			return;&#13;
		}&#13;
		m_Age = age;&#13;
	}&#13;
&#13;
	//情人设置为只写&#13;
	void setLover(string lover) {&#13;
		m_Lover = lover;&#13;
	}&#13;
&#13;
private:&#13;
	string m_Name; //可读可写  姓名&#13;
	&#13;
	int m_Age; //只读  年龄&#13;
&#13;
	string m_Lover; //只写  情人&#13;
};&#13;
&#13;
int main() {&#13;
&#13;
	Person p;&#13;
	//姓名设置&#13;
	p.setName('张三');&#13;
	cout &lt;&lt; '姓名： ' &lt;&lt; p.getName() &lt;&lt; endl;&#13;
&#13;
	//年龄设置&#13;
	p.setAge(50);&#13;
	cout &lt;&lt; '年龄： ' &lt;&lt; p.getAge() &lt;&lt; endl;&#13;
&#13;
	//情人设置&#13;
	p.setLover('苍井');&#13;
	//cout &lt;&lt; '情人： ' &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取&#13;
&#13;
	return 0;&#13;
}&#13;
```&#13;
&#13;
#### 1.2 对象的初始化和清理&#13;
&#13;
*   生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全&#13;
*   C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</description><guid isPermaLink="true">https://nickyoung0514.github.io/yblog.github.io/post/%E3%80%90C%2B%2B-he-xin-%E3%80%91-yi-wen-li-jie-C%2B%2B-mian-xiang-dui-xiang-%EF%BC%88-xiang-xi-%EF%BC%89.html</guid><pubDate>Thu, 20 Jun 2024 11:27:48 +0000</pubDate></item><item><title>诗词</title><link>https://nickyoung0514.github.io/yblog.github.io/post/shi-ci.html</link><description>&#13;
&#13;
# 一蓑烟雨任平生&#13;
&#13;
## 定风波·莫听穿林打叶声&#13;
&#13;
        作者：[苏轼]&#13;
&#13;
　　三月七日，沙湖道中遇雨。</description><guid isPermaLink="true">https://nickyoung0514.github.io/yblog.github.io/post/shi-ci.html</guid><pubDate>Thu, 20 Jun 2024 09:25:07 +0000</pubDate></item></channel></rss>